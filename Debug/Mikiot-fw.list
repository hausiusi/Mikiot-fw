
Mikiot-fw.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000188  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         000012b0  08000190  08000190  00010190  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       0000001c  08001440  08001440  00011440  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  0800145c  0800145c  00020474  2**0
                  CONTENTS
  4 .ARM          00000000  0800145c  0800145c  00020474  2**0
                  CONTENTS
  5 .preinit_array 00000000  0800145c  0800145c  00020474  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000008  0800145c  0800145c  0001145c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .fini_array   00000004  08001464  08001464  00011464  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .data         00000474  20000000  08001468  00020000  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          00003db8  20000474  080018dc  00020474  2**2
                  ALLOC
 10 ._user_heap_stack 00000604  2000422c  080018dc  0002422c  2**0
                  ALLOC
 11 .ARM.attributes 00000030  00000000  00000000  00020474  2**0
                  CONTENTS, READONLY
 12 .debug_info   0000e09f  00000000  00000000  000204a4  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_abbrev 0000206a  00000000  00000000  0002e543  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_aranges 000009a8  00000000  00000000  000305b0  2**3
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_ranges 000009e8  00000000  00000000  00030f58  2**3
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_macro  00021e36  00000000  00000000  00031940  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_line   0000a94f  00000000  00000000  00053776  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_str    000cca05  00000000  00000000  0005e0c5  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .comment      0000007b  00000000  00000000  0012aaca  2**0
                  CONTENTS, READONLY
 20 .debug_frame  000019c8  00000000  00000000  0012ab48  2**2
                  CONTENTS, READONLY, DEBUGGING
 21 .debug_loc    00006172  00000000  00000000  0012c510  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

08000190 <__do_global_dtors_aux>:
 8000190:	b510      	push	{r4, lr}
 8000192:	4c05      	ldr	r4, [pc, #20]	; (80001a8 <__do_global_dtors_aux+0x18>)
 8000194:	7823      	ldrb	r3, [r4, #0]
 8000196:	b933      	cbnz	r3, 80001a6 <__do_global_dtors_aux+0x16>
 8000198:	4b04      	ldr	r3, [pc, #16]	; (80001ac <__do_global_dtors_aux+0x1c>)
 800019a:	b113      	cbz	r3, 80001a2 <__do_global_dtors_aux+0x12>
 800019c:	4804      	ldr	r0, [pc, #16]	; (80001b0 <__do_global_dtors_aux+0x20>)
 800019e:	f3af 8000 	nop.w
 80001a2:	2301      	movs	r3, #1
 80001a4:	7023      	strb	r3, [r4, #0]
 80001a6:	bd10      	pop	{r4, pc}
 80001a8:	20000474 	.word	0x20000474
 80001ac:	00000000 	.word	0x00000000
 80001b0:	08001428 	.word	0x08001428

080001b4 <frame_dummy>:
 80001b4:	b508      	push	{r3, lr}
 80001b6:	4b03      	ldr	r3, [pc, #12]	; (80001c4 <frame_dummy+0x10>)
 80001b8:	b11b      	cbz	r3, 80001c2 <frame_dummy+0xe>
 80001ba:	4903      	ldr	r1, [pc, #12]	; (80001c8 <frame_dummy+0x14>)
 80001bc:	4803      	ldr	r0, [pc, #12]	; (80001cc <frame_dummy+0x18>)
 80001be:	f3af 8000 	nop.w
 80001c2:	bd08      	pop	{r3, pc}
 80001c4:	00000000 	.word	0x00000000
 80001c8:	20000478 	.word	0x20000478
 80001cc:	08001428 	.word	0x08001428

080001d0 <main>:
  * @brief  The application entry point.
  * @retval int
  */

int main(void)
{
 80001d0:	b508      	push	{r3, lr}
	mw_hal_init();
 80001d2:	f000 f883 	bl	80002dc <HAL_Init>
	os_start();
 80001d6:	f001 f85d 	bl	8001294 <os_start>
 80001da:	e7fe      	b.n	80001da <main+0xa>

080001dc <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 80001dc:	b082      	sub	sp, #8
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
 80001de:	2100      	movs	r1, #0
 80001e0:	9100      	str	r1, [sp, #0]
 80001e2:	4b0b      	ldr	r3, [pc, #44]	; (8000210 <HAL_MspInit+0x34>)
 80001e4:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 80001e6:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 80001ea:	645a      	str	r2, [r3, #68]	; 0x44
 80001ec:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 80001ee:	f402 4280 	and.w	r2, r2, #16384	; 0x4000
 80001f2:	9200      	str	r2, [sp, #0]
 80001f4:	9a00      	ldr	r2, [sp, #0]
  __HAL_RCC_PWR_CLK_ENABLE();
 80001f6:	9101      	str	r1, [sp, #4]
 80001f8:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80001fa:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 80001fe:	641a      	str	r2, [r3, #64]	; 0x40
 8000200:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8000202:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8000206:	9301      	str	r3, [sp, #4]
 8000208:	9b01      	ldr	r3, [sp, #4]
  /* System interrupt init*/

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 800020a:	b002      	add	sp, #8
 800020c:	4770      	bx	lr
 800020e:	bf00      	nop
 8000210:	40023800 	.word	0x40023800

08000214 <NMI_Handler>:

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */

  /* USER CODE END NonMaskableInt_IRQn 1 */
}
 8000214:	4770      	bx	lr

08000216 <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
 8000216:	e7fe      	b.n	8000216 <HardFault_Handler>

08000218 <MemManage_Handler>:

/**
  * @brief This function handles Memory management fault.
  */
void MemManage_Handler(void)
{
 8000218:	e7fe      	b.n	8000218 <MemManage_Handler>

0800021a <BusFault_Handler>:

/**
  * @brief This function handles Pre-fetch fault, memory access fault.
  */
void BusFault_Handler(void)
{
 800021a:	e7fe      	b.n	800021a <BusFault_Handler>

0800021c <UsageFault_Handler>:

/**
  * @brief This function handles Undefined instruction or illegal state.
  */
void UsageFault_Handler(void)
{
 800021c:	e7fe      	b.n	800021c <UsageFault_Handler>

0800021e <DebugMon_Handler>:

  /* USER CODE END DebugMonitor_IRQn 0 */
  /* USER CODE BEGIN DebugMonitor_IRQn 1 */

  /* USER CODE END DebugMonitor_IRQn 1 */
}
 800021e:	4770      	bx	lr

08000220 <SystemInit>:
  */
void SystemInit(void)
{
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 8000220:	4b05      	ldr	r3, [pc, #20]	; (8000238 <SystemInit+0x18>)
 8000222:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 8000226:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
 800022a:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 800022e:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 8000232:	609a      	str	r2, [r3, #8]
#endif
}
 8000234:	4770      	bx	lr
 8000236:	bf00      	nop
 8000238:	e000ed00 	.word	0xe000ed00

0800023c <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
  ldr   sp, =_estack     /* set stack pointer */
 800023c:	f8df d034 	ldr.w	sp, [pc, #52]	; 8000274 <LoopFillZerobss+0x14>

/* Copy the data segment initializers from flash to SRAM */  
  movs  r1, #0
 8000240:	2100      	movs	r1, #0
  b  LoopCopyDataInit
 8000242:	e003      	b.n	800024c <LoopCopyDataInit>

08000244 <CopyDataInit>:

CopyDataInit:
  ldr  r3, =_sidata
 8000244:	4b0c      	ldr	r3, [pc, #48]	; (8000278 <LoopFillZerobss+0x18>)
  ldr  r3, [r3, r1]
 8000246:	585b      	ldr	r3, [r3, r1]
  str  r3, [r0, r1]
 8000248:	5043      	str	r3, [r0, r1]
  adds  r1, r1, #4
 800024a:	3104      	adds	r1, #4

0800024c <LoopCopyDataInit>:
    
LoopCopyDataInit:
  ldr  r0, =_sdata
 800024c:	480b      	ldr	r0, [pc, #44]	; (800027c <LoopFillZerobss+0x1c>)
  ldr  r3, =_edata
 800024e:	4b0c      	ldr	r3, [pc, #48]	; (8000280 <LoopFillZerobss+0x20>)
  adds  r2, r0, r1
 8000250:	1842      	adds	r2, r0, r1
  cmp  r2, r3
 8000252:	429a      	cmp	r2, r3
  bcc  CopyDataInit
 8000254:	d3f6      	bcc.n	8000244 <CopyDataInit>
  ldr  r2, =_sbss
 8000256:	4a0b      	ldr	r2, [pc, #44]	; (8000284 <LoopFillZerobss+0x24>)
  b  LoopFillZerobss
 8000258:	e002      	b.n	8000260 <LoopFillZerobss>

0800025a <FillZerobss>:
/* Zero fill the bss segment. */  
FillZerobss:
  movs  r3, #0
 800025a:	2300      	movs	r3, #0
  str  r3, [r2], #4
 800025c:	f842 3b04 	str.w	r3, [r2], #4

08000260 <LoopFillZerobss>:
    
LoopFillZerobss:
  ldr  r3, = _ebss
 8000260:	4b09      	ldr	r3, [pc, #36]	; (8000288 <LoopFillZerobss+0x28>)
  cmp  r2, r3
 8000262:	429a      	cmp	r2, r3
  bcc  FillZerobss
 8000264:	d3f9      	bcc.n	800025a <FillZerobss>

/* Call the clock system intitialization function.*/
  bl  SystemInit   
 8000266:	f7ff ffdb 	bl	8000220 <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 800026a:	f001 f835 	bl	80012d8 <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 800026e:	f7ff ffaf 	bl	80001d0 <main>
  bx  lr    
 8000272:	4770      	bx	lr
  ldr   sp, =_estack     /* set stack pointer */
 8000274:	20020000 	.word	0x20020000
  ldr  r3, =_sidata
 8000278:	08001468 	.word	0x08001468
  ldr  r0, =_sdata
 800027c:	20000000 	.word	0x20000000
  ldr  r3, =_edata
 8000280:	20000474 	.word	0x20000474
  ldr  r2, =_sbss
 8000284:	20000474 	.word	0x20000474
  ldr  r3, = _ebss
 8000288:	2000422c 	.word	0x2000422c

0800028c <ADC_IRQHandler>:
 * @retval None       
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 800028c:	e7fe      	b.n	800028c <ADC_IRQHandler>
	...

08000290 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 8000290:	b510      	push	{r4, lr}
 8000292:	4604      	mov	r4, r0
  /* Configure the SysTick to have interrupt in 1ms time basis*/
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) > 0U)
 8000294:	4b0e      	ldr	r3, [pc, #56]	; (80002d0 <HAL_InitTick+0x40>)
 8000296:	7818      	ldrb	r0, [r3, #0]
 8000298:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 800029c:	fbb3 f3f0 	udiv	r3, r3, r0
 80002a0:	4a0c      	ldr	r2, [pc, #48]	; (80002d4 <HAL_InitTick+0x44>)
 80002a2:	6810      	ldr	r0, [r2, #0]
 80002a4:	fbb0 f0f3 	udiv	r0, r0, r3
 80002a8:	f000 f878 	bl	800039c <HAL_SYSTICK_Config>
 80002ac:	b968      	cbnz	r0, 80002ca <HAL_InitTick+0x3a>
  {
    return HAL_ERROR;
  }

  /* Configure the SysTick IRQ priority */
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 80002ae:	2c0f      	cmp	r4, #15
 80002b0:	d901      	bls.n	80002b6 <HAL_InitTick+0x26>
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
    uwTickPrio = TickPriority;
  }
  else
  {
    return HAL_ERROR;
 80002b2:	2001      	movs	r0, #1
 80002b4:	e00a      	b.n	80002cc <HAL_InitTick+0x3c>
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
 80002b6:	2200      	movs	r2, #0
 80002b8:	4621      	mov	r1, r4
 80002ba:	f04f 30ff 	mov.w	r0, #4294967295
 80002be:	f000 f839 	bl	8000334 <HAL_NVIC_SetPriority>
    uwTickPrio = TickPriority;
 80002c2:	4b05      	ldr	r3, [pc, #20]	; (80002d8 <HAL_InitTick+0x48>)
 80002c4:	601c      	str	r4, [r3, #0]
  }

  /* Return function status */
  return HAL_OK;
 80002c6:	2000      	movs	r0, #0
 80002c8:	e000      	b.n	80002cc <HAL_InitTick+0x3c>
    return HAL_ERROR;
 80002ca:	2001      	movs	r0, #1
}
 80002cc:	bd10      	pop	{r4, pc}
 80002ce:	bf00      	nop
 80002d0:	20000004 	.word	0x20000004
 80002d4:	20000000 	.word	0x20000000
 80002d8:	20000008 	.word	0x20000008

080002dc <HAL_Init>:
{
 80002dc:	b508      	push	{r3, lr}
  __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
 80002de:	4b0b      	ldr	r3, [pc, #44]	; (800030c <HAL_Init+0x30>)
 80002e0:	681a      	ldr	r2, [r3, #0]
 80002e2:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 80002e6:	601a      	str	r2, [r3, #0]
  __HAL_FLASH_DATA_CACHE_ENABLE();
 80002e8:	681a      	ldr	r2, [r3, #0]
 80002ea:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 80002ee:	601a      	str	r2, [r3, #0]
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 80002f0:	681a      	ldr	r2, [r3, #0]
 80002f2:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 80002f6:	601a      	str	r2, [r3, #0]
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 80002f8:	2003      	movs	r0, #3
 80002fa:	f000 f809 	bl	8000310 <HAL_NVIC_SetPriorityGrouping>
  HAL_InitTick(TICK_INT_PRIORITY);
 80002fe:	2000      	movs	r0, #0
 8000300:	f7ff ffc6 	bl	8000290 <HAL_InitTick>
  HAL_MspInit();
 8000304:	f7ff ff6a 	bl	80001dc <HAL_MspInit>
}
 8000308:	2000      	movs	r0, #0
 800030a:	bd08      	pop	{r3, pc}
 800030c:	40023c00 	.word	0x40023c00

08000310 <HAL_NVIC_SetPriorityGrouping>:
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8000310:	4a07      	ldr	r2, [pc, #28]	; (8000330 <HAL_NVIC_SetPriorityGrouping+0x20>)
 8000312:	68d3      	ldr	r3, [r2, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8000314:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 8000318:	041b      	lsls	r3, r3, #16
 800031a:	0c1b      	lsrs	r3, r3, #16
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 800031c:	0200      	lsls	r0, r0, #8
 800031e:	f400 60e0 	and.w	r0, r0, #1792	; 0x700
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 8000322:	4318      	orrs	r0, r3
  reg_value  =  (reg_value                                   |
 8000324:	f040 60bf 	orr.w	r0, r0, #100139008	; 0x5f80000
 8000328:	f440 3000 	orr.w	r0, r0, #131072	; 0x20000
  SCB->AIRCR =  reg_value;
 800032c:	60d0      	str	r0, [r2, #12]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
  
  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
}
 800032e:	4770      	bx	lr
 8000330:	e000ed00 	.word	0xe000ed00

08000334 <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.          
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 8000334:	b430      	push	{r4, r5}
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8000336:	4b17      	ldr	r3, [pc, #92]	; (8000394 <HAL_NVIC_SetPriority+0x60>)
 8000338:	68db      	ldr	r3, [r3, #12]
 800033a:	f3c3 2302 	ubfx	r3, r3, #8, #3
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 800033e:	f1c3 0407 	rsb	r4, r3, #7
 8000342:	2c04      	cmp	r4, #4
 8000344:	bf28      	it	cs
 8000346:	2404      	movcs	r4, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8000348:	1d1d      	adds	r5, r3, #4
 800034a:	2d06      	cmp	r5, #6
 800034c:	d918      	bls.n	8000380 <HAL_NVIC_SetPriority+0x4c>
 800034e:	3b03      	subs	r3, #3

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8000350:	f04f 35ff 	mov.w	r5, #4294967295
 8000354:	fa05 f404 	lsl.w	r4, r5, r4
 8000358:	ea21 0104 	bic.w	r1, r1, r4
 800035c:	4099      	lsls	r1, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 800035e:	fa05 f303 	lsl.w	r3, r5, r3
 8000362:	ea22 0303 	bic.w	r3, r2, r3
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8000366:	4319      	orrs	r1, r3
  if ((int32_t)(IRQn) >= 0)
 8000368:	2800      	cmp	r0, #0
 800036a:	db0b      	blt.n	8000384 <HAL_NVIC_SetPriority+0x50>
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800036c:	0109      	lsls	r1, r1, #4
 800036e:	b2c9      	uxtb	r1, r1
 8000370:	f100 4060 	add.w	r0, r0, #3758096384	; 0xe0000000
 8000374:	f500 4061 	add.w	r0, r0, #57600	; 0xe100
 8000378:	f880 1300 	strb.w	r1, [r0, #768]	; 0x300
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  
  prioritygroup = NVIC_GetPriorityGrouping();
  
  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
}
 800037c:	bc30      	pop	{r4, r5}
 800037e:	4770      	bx	lr
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8000380:	2300      	movs	r3, #0
 8000382:	e7e5      	b.n	8000350 <HAL_NVIC_SetPriority+0x1c>
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000384:	f000 000f 	and.w	r0, r0, #15
 8000388:	0109      	lsls	r1, r1, #4
 800038a:	b2c9      	uxtb	r1, r1
 800038c:	4b02      	ldr	r3, [pc, #8]	; (8000398 <HAL_NVIC_SetPriority+0x64>)
 800038e:	5419      	strb	r1, [r3, r0]
 8000390:	e7f4      	b.n	800037c <HAL_NVIC_SetPriority+0x48>
 8000392:	bf00      	nop
 8000394:	e000ed00 	.word	0xe000ed00
 8000398:	e000ed14 	.word	0xe000ed14

0800039c <HAL_SYSTICK_Config>:
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 800039c:	3801      	subs	r0, #1
 800039e:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 80003a2:	d20a      	bcs.n	80003ba <HAL_SYSTICK_Config+0x1e>
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 80003a4:	4b06      	ldr	r3, [pc, #24]	; (80003c0 <HAL_SYSTICK_Config+0x24>)
 80003a6:	6058      	str	r0, [r3, #4]
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80003a8:	4a06      	ldr	r2, [pc, #24]	; (80003c4 <HAL_SYSTICK_Config+0x28>)
 80003aa:	21f0      	movs	r1, #240	; 0xf0
 80003ac:	f882 1023 	strb.w	r1, [r2, #35]	; 0x23
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 80003b0:	2000      	movs	r0, #0
 80003b2:	6098      	str	r0, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 80003b4:	2207      	movs	r2, #7
 80003b6:	601a      	str	r2, [r3, #0]
 80003b8:	4770      	bx	lr
    return (1UL);                                                   /* Reload value impossible */
 80003ba:	2001      	movs	r0, #1
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
   return SysTick_Config(TicksNumb);
}
 80003bc:	4770      	bx	lr
 80003be:	bf00      	nop
 80003c0:	e000e010 	.word	0xe000e010
 80003c4:	e000ed00 	.word	0xe000ed00

080003c8 <HAL_TIM_Base_MspInit>:
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_Base_MspInit could be implemented in the user file
   */
}
 80003c8:	4770      	bx	lr

080003ca <HAL_TIM_Base_Start>:

  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));

  /* Set the TIM state */
  htim->State = HAL_TIM_STATE_BUSY;
 80003ca:	2302      	movs	r3, #2
 80003cc:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d

  /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
  tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 80003d0:	6802      	ldr	r2, [r0, #0]
 80003d2:	6893      	ldr	r3, [r2, #8]
 80003d4:	f003 0307 	and.w	r3, r3, #7
  if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 80003d8:	2b06      	cmp	r3, #6
 80003da:	d003      	beq.n	80003e4 <HAL_TIM_Base_Start+0x1a>
  {
    __HAL_TIM_ENABLE(htim);
 80003dc:	6813      	ldr	r3, [r2, #0]
 80003de:	f043 0301 	orr.w	r3, r3, #1
 80003e2:	6013      	str	r3, [r2, #0]
  }

  /* Change the TIM state*/
  htim->State = HAL_TIM_STATE_READY;
 80003e4:	2301      	movs	r3, #1
 80003e6:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d

  /* Return function status */
  return HAL_OK;
}
 80003ea:	2000      	movs	r0, #0
 80003ec:	4770      	bx	lr
	...

080003f0 <TIM_Base_SetConfig>:
  * @retval None
  */
void TIM_Base_SetConfig(TIM_TypeDef *TIMx, TIM_Base_InitTypeDef *Structure)
{
  uint32_t tmpcr1;
  tmpcr1 = TIMx->CR1;
 80003f0:	6803      	ldr	r3, [r0, #0]

  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 80003f2:	4a30      	ldr	r2, [pc, #192]	; (80004b4 <TIM_Base_SetConfig+0xc4>)
 80003f4:	4290      	cmp	r0, r2
 80003f6:	d012      	beq.n	800041e <TIM_Base_SetConfig+0x2e>
 80003f8:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
 80003fc:	d00f      	beq.n	800041e <TIM_Base_SetConfig+0x2e>
 80003fe:	f5a2 427c 	sub.w	r2, r2, #64512	; 0xfc00
 8000402:	4290      	cmp	r0, r2
 8000404:	d00b      	beq.n	800041e <TIM_Base_SetConfig+0x2e>
 8000406:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 800040a:	4290      	cmp	r0, r2
 800040c:	d007      	beq.n	800041e <TIM_Base_SetConfig+0x2e>
 800040e:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8000412:	4290      	cmp	r0, r2
 8000414:	d003      	beq.n	800041e <TIM_Base_SetConfig+0x2e>
 8000416:	f502 4278 	add.w	r2, r2, #63488	; 0xf800
 800041a:	4290      	cmp	r0, r2
 800041c:	d103      	bne.n	8000426 <TIM_Base_SetConfig+0x36>
  {
    /* Select the Counter Mode */
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 800041e:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
 8000422:	684a      	ldr	r2, [r1, #4]
 8000424:	4313      	orrs	r3, r2
  }

  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 8000426:	4a23      	ldr	r2, [pc, #140]	; (80004b4 <TIM_Base_SetConfig+0xc4>)
 8000428:	4290      	cmp	r0, r2
 800042a:	d02a      	beq.n	8000482 <TIM_Base_SetConfig+0x92>
 800042c:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
 8000430:	d027      	beq.n	8000482 <TIM_Base_SetConfig+0x92>
 8000432:	f5a2 427c 	sub.w	r2, r2, #64512	; 0xfc00
 8000436:	4290      	cmp	r0, r2
 8000438:	d023      	beq.n	8000482 <TIM_Base_SetConfig+0x92>
 800043a:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 800043e:	4290      	cmp	r0, r2
 8000440:	d01f      	beq.n	8000482 <TIM_Base_SetConfig+0x92>
 8000442:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8000446:	4290      	cmp	r0, r2
 8000448:	d01b      	beq.n	8000482 <TIM_Base_SetConfig+0x92>
 800044a:	f502 4278 	add.w	r2, r2, #63488	; 0xf800
 800044e:	4290      	cmp	r0, r2
 8000450:	d017      	beq.n	8000482 <TIM_Base_SetConfig+0x92>
 8000452:	f502 5270 	add.w	r2, r2, #15360	; 0x3c00
 8000456:	4290      	cmp	r0, r2
 8000458:	d013      	beq.n	8000482 <TIM_Base_SetConfig+0x92>
 800045a:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 800045e:	4290      	cmp	r0, r2
 8000460:	d00f      	beq.n	8000482 <TIM_Base_SetConfig+0x92>
 8000462:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8000466:	4290      	cmp	r0, r2
 8000468:	d00b      	beq.n	8000482 <TIM_Base_SetConfig+0x92>
 800046a:	f5a2 3298 	sub.w	r2, r2, #77824	; 0x13000
 800046e:	4290      	cmp	r0, r2
 8000470:	d007      	beq.n	8000482 <TIM_Base_SetConfig+0x92>
 8000472:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8000476:	4290      	cmp	r0, r2
 8000478:	d003      	beq.n	8000482 <TIM_Base_SetConfig+0x92>
 800047a:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 800047e:	4290      	cmp	r0, r2
 8000480:	d103      	bne.n	800048a <TIM_Base_SetConfig+0x9a>
  {
    /* Set the clock division */
    tmpcr1 &= ~TIM_CR1_CKD;
 8000482:	f423 7340 	bic.w	r3, r3, #768	; 0x300
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8000486:	68ca      	ldr	r2, [r1, #12]
 8000488:	4313      	orrs	r3, r2
  }

  /* Set the auto-reload preload */
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 800048a:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 800048e:	694a      	ldr	r2, [r1, #20]
 8000490:	4313      	orrs	r3, r2

  TIMx->CR1 = tmpcr1;
 8000492:	6003      	str	r3, [r0, #0]

  /* Set the Autoreload value */
  TIMx->ARR = (uint32_t)Structure->Period ;
 8000494:	688b      	ldr	r3, [r1, #8]
 8000496:	62c3      	str	r3, [r0, #44]	; 0x2c

  /* Set the Prescaler value */
  TIMx->PSC = Structure->Prescaler;
 8000498:	680b      	ldr	r3, [r1, #0]
 800049a:	6283      	str	r3, [r0, #40]	; 0x28

  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 800049c:	4b05      	ldr	r3, [pc, #20]	; (80004b4 <TIM_Base_SetConfig+0xc4>)
 800049e:	4298      	cmp	r0, r3
 80004a0:	d003      	beq.n	80004aa <TIM_Base_SetConfig+0xba>
 80004a2:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 80004a6:	4298      	cmp	r0, r3
 80004a8:	d101      	bne.n	80004ae <TIM_Base_SetConfig+0xbe>
  {
    /* Set the Repetition Counter value */
    TIMx->RCR = Structure->RepetitionCounter;
 80004aa:	690b      	ldr	r3, [r1, #16]
 80004ac:	6303      	str	r3, [r0, #48]	; 0x30
  }

  /* Generate an update event to reload the Prescaler
     and the repetition counter (only for advanced timer) value immediately */
  TIMx->EGR = TIM_EGR_UG;
 80004ae:	2301      	movs	r3, #1
 80004b0:	6143      	str	r3, [r0, #20]
}
 80004b2:	4770      	bx	lr
 80004b4:	40010000 	.word	0x40010000

080004b8 <HAL_TIM_Base_Init>:
  if (htim == NULL)
 80004b8:	b1a8      	cbz	r0, 80004e6 <HAL_TIM_Base_Init+0x2e>
{
 80004ba:	b510      	push	{r4, lr}
 80004bc:	4604      	mov	r4, r0
  if (htim->State == HAL_TIM_STATE_RESET)
 80004be:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 80004c2:	b15b      	cbz	r3, 80004dc <HAL_TIM_Base_Init+0x24>
  htim->State = HAL_TIM_STATE_BUSY;
 80004c4:	2302      	movs	r3, #2
 80004c6:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 80004ca:	1d21      	adds	r1, r4, #4
 80004cc:	6820      	ldr	r0, [r4, #0]
 80004ce:	f7ff ff8f 	bl	80003f0 <TIM_Base_SetConfig>
  htim->State = HAL_TIM_STATE_READY;
 80004d2:	2301      	movs	r3, #1
 80004d4:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  return HAL_OK;
 80004d8:	2000      	movs	r0, #0
}
 80004da:	bd10      	pop	{r4, pc}
    htim->Lock = HAL_UNLOCKED;
 80004dc:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
    HAL_TIM_Base_MspInit(htim);
 80004e0:	f7ff ff72 	bl	80003c8 <HAL_TIM_Base_MspInit>
 80004e4:	e7ee      	b.n	80004c4 <HAL_TIM_Base_Init+0xc>
    return HAL_ERROR;
 80004e6:	2001      	movs	r0, #1
}
 80004e8:	4770      	bx	lr

080004ea <vListInitialise>:
void vListInitialise( List_t * const pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 80004ea:	f100 0308 	add.w	r3, r0, #8
 80004ee:	6043      	str	r3, [r0, #4]

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 80004f0:	f04f 32ff 	mov.w	r2, #4294967295
 80004f4:	6082      	str	r2, [r0, #8]

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 80004f6:	60c3      	str	r3, [r0, #12]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 80004f8:	6103      	str	r3, [r0, #16]

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 80004fa:	2300      	movs	r3, #0
 80004fc:	6003      	str	r3, [r0, #0]

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
 80004fe:	4770      	bx	lr

08000500 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
 8000500:	2300      	movs	r3, #0
 8000502:	6103      	str	r3, [r0, #16]

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
 8000504:	4770      	bx	lr

08000506 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
ListItem_t * const pxIndex = pxList->pxIndex;
 8000506:	6843      	ldr	r3, [r0, #4]
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
 8000508:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 800050a:	689a      	ldr	r2, [r3, #8]
 800050c:	608a      	str	r2, [r1, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
 800050e:	689a      	ldr	r2, [r3, #8]
 8000510:	6051      	str	r1, [r2, #4]
	pxIndex->pxPrevious = pxNewListItem;
 8000512:	6099      	str	r1, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
 8000514:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
 8000516:	6803      	ldr	r3, [r0, #0]
 8000518:	3301      	adds	r3, #1
 800051a:	6003      	str	r3, [r0, #0]
}
 800051c:	4770      	bx	lr

0800051e <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 800051e:	b430      	push	{r4, r5}
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 8000520:	680d      	ldr	r5, [r1, #0]
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 8000522:	f1b5 3fff 	cmp.w	r5, #4294967295
 8000526:	d002      	beq.n	800052e <vListInsert+0x10>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
 8000528:	f100 0208 	add.w	r2, r0, #8
 800052c:	e002      	b.n	8000534 <vListInsert+0x16>
		pxIterator = pxList->xListEnd.pxPrevious;
 800052e:	6902      	ldr	r2, [r0, #16]
 8000530:	e004      	b.n	800053c <vListInsert+0x1e>
		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
 8000532:	461a      	mov	r2, r3
 8000534:	6853      	ldr	r3, [r2, #4]
 8000536:	681c      	ldr	r4, [r3, #0]
 8000538:	42ac      	cmp	r4, r5
 800053a:	d9fa      	bls.n	8000532 <vListInsert+0x14>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 800053c:	6853      	ldr	r3, [r2, #4]
 800053e:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 8000540:	6099      	str	r1, [r3, #8]
	pxNewListItem->pxPrevious = pxIterator;
 8000542:	608a      	str	r2, [r1, #8]
	pxIterator->pxNext = pxNewListItem;
 8000544:	6051      	str	r1, [r2, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
 8000546:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
 8000548:	6803      	ldr	r3, [r0, #0]
 800054a:	3301      	adds	r3, #1
 800054c:	6003      	str	r3, [r0, #0]
}
 800054e:	bc30      	pop	{r4, r5}
 8000550:	4770      	bx	lr

08000552 <uxListRemove>:

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
 8000552:	6903      	ldr	r3, [r0, #16]

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 8000554:	6842      	ldr	r2, [r0, #4]
 8000556:	6881      	ldr	r1, [r0, #8]
 8000558:	6091      	str	r1, [r2, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 800055a:	6882      	ldr	r2, [r0, #8]
 800055c:	6841      	ldr	r1, [r0, #4]
 800055e:	6051      	str	r1, [r2, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 8000560:	685a      	ldr	r2, [r3, #4]
 8000562:	4282      	cmp	r2, r0
 8000564:	d006      	beq.n	8000574 <uxListRemove+0x22>
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
 8000566:	2200      	movs	r2, #0
 8000568:	6102      	str	r2, [r0, #16]
	( pxList->uxNumberOfItems )--;
 800056a:	681a      	ldr	r2, [r3, #0]
 800056c:	3a01      	subs	r2, #1
 800056e:	601a      	str	r2, [r3, #0]

	return pxList->uxNumberOfItems;
 8000570:	6818      	ldr	r0, [r3, #0]
}
 8000572:	4770      	bx	lr
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 8000574:	6882      	ldr	r2, [r0, #8]
 8000576:	605a      	str	r2, [r3, #4]
 8000578:	e7f5      	b.n	8000566 <uxListRemove+0x14>
	...

0800057c <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 800057c:	4b08      	ldr	r3, [pc, #32]	; (80005a0 <prvResetNextTaskUnblockTime+0x24>)
 800057e:	681b      	ldr	r3, [r3, #0]
 8000580:	681b      	ldr	r3, [r3, #0]
 8000582:	b13b      	cbz	r3, 8000594 <prvResetNextTaskUnblockTime+0x18>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8000584:	4b06      	ldr	r3, [pc, #24]	; (80005a0 <prvResetNextTaskUnblockTime+0x24>)
 8000586:	681b      	ldr	r3, [r3, #0]
 8000588:	68db      	ldr	r3, [r3, #12]
 800058a:	68db      	ldr	r3, [r3, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 800058c:	685a      	ldr	r2, [r3, #4]
 800058e:	4b05      	ldr	r3, [pc, #20]	; (80005a4 <prvResetNextTaskUnblockTime+0x28>)
 8000590:	601a      	str	r2, [r3, #0]
	}
}
 8000592:	4770      	bx	lr
		xNextTaskUnblockTime = portMAX_DELAY;
 8000594:	4b03      	ldr	r3, [pc, #12]	; (80005a4 <prvResetNextTaskUnblockTime+0x28>)
 8000596:	f04f 32ff 	mov.w	r2, #4294967295
 800059a:	601a      	str	r2, [r3, #0]
 800059c:	4770      	bx	lr
 800059e:	bf00      	nop
 80005a0:	20000494 	.word	0x20000494
 80005a4:	20000570 	.word	0x20000570

080005a8 <prvDeleteTCB>:
	{
 80005a8:	b510      	push	{r4, lr}
 80005aa:	4604      	mov	r4, r0
			vPortFree( pxTCB->pxStack );
 80005ac:	6b00      	ldr	r0, [r0, #48]	; 0x30
 80005ae:	f000 fdd5 	bl	800115c <vPortFree>
			vPortFree( pxTCB );
 80005b2:	4620      	mov	r0, r4
 80005b4:	f000 fdd2 	bl	800115c <vPortFree>
	}
 80005b8:	bd10      	pop	{r4, pc}

080005ba <prvInitialiseNewTask>:
{
 80005ba:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80005be:	4681      	mov	r9, r0
 80005c0:	460d      	mov	r5, r1
 80005c2:	4617      	mov	r7, r2
 80005c4:	469a      	mov	sl, r3
 80005c6:	9e08      	ldr	r6, [sp, #32]
 80005c8:	f8dd 8024 	ldr.w	r8, [sp, #36]	; 0x24
 80005cc:	9c0a      	ldr	r4, [sp, #40]	; 0x28
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
 80005ce:	0092      	lsls	r2, r2, #2
 80005d0:	21a5      	movs	r1, #165	; 0xa5
 80005d2:	6b20      	ldr	r0, [r4, #48]	; 0x30
 80005d4:	f000 fea4 	bl	8001320 <memset>
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
 80005d8:	6b23      	ldr	r3, [r4, #48]	; 0x30
 80005da:	f107 4280 	add.w	r2, r7, #1073741824	; 0x40000000
 80005de:	3a01      	subs	r2, #1
 80005e0:	eb03 0782 	add.w	r7, r3, r2, lsl #2
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 !e9033 !e9078 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type.  Checked by assert(). */
 80005e4:	f027 0707 	bic.w	r7, r7, #7
	if( pcName != NULL )
 80005e8:	b38d      	cbz	r5, 800064e <prvInitialiseNewTask+0x94>
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 80005ea:	2300      	movs	r3, #0
 80005ec:	2b0f      	cmp	r3, #15
 80005ee:	d807      	bhi.n	8000600 <prvInitialiseNewTask+0x46>
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 80005f0:	5ce9      	ldrb	r1, [r5, r3]
 80005f2:	18e2      	adds	r2, r4, r3
 80005f4:	f882 1034 	strb.w	r1, [r2, #52]	; 0x34
			if( pcName[ x ] == ( char ) 0x00 )
 80005f8:	5cea      	ldrb	r2, [r5, r3]
 80005fa:	b10a      	cbz	r2, 8000600 <prvInitialiseNewTask+0x46>
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 80005fc:	3301      	adds	r3, #1
 80005fe:	e7f5      	b.n	80005ec <prvInitialiseNewTask+0x32>
		pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 8000600:	2300      	movs	r3, #0
 8000602:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 8000606:	2e06      	cmp	r6, #6
 8000608:	d900      	bls.n	800060c <prvInitialiseNewTask+0x52>
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
 800060a:	2606      	movs	r6, #6
	pxNewTCB->uxPriority = uxPriority;
 800060c:	62e6      	str	r6, [r4, #44]	; 0x2c
		pxNewTCB->uxBasePriority = uxPriority;
 800060e:	64e6      	str	r6, [r4, #76]	; 0x4c
		pxNewTCB->uxMutexesHeld = 0;
 8000610:	2500      	movs	r5, #0
 8000612:	6525      	str	r5, [r4, #80]	; 0x50
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 8000614:	1d20      	adds	r0, r4, #4
 8000616:	f7ff ff73 	bl	8000500 <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 800061a:	f104 0018 	add.w	r0, r4, #24
 800061e:	f7ff ff6f 	bl	8000500 <vListInitialiseItem>
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 8000622:	6124      	str	r4, [r4, #16]
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8000624:	f1c6 0607 	rsb	r6, r6, #7
 8000628:	61a6      	str	r6, [r4, #24]
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 800062a:	6264      	str	r4, [r4, #36]	; 0x24
		pxNewTCB->ulRunTimeCounter = 0UL;
 800062c:	6565      	str	r5, [r4, #84]	; 0x54
		pxNewTCB->ulNotifiedValue = 0;
 800062e:	65a5      	str	r5, [r4, #88]	; 0x58
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 8000630:	f884 505c 	strb.w	r5, [r4, #92]	; 0x5c
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 8000634:	4652      	mov	r2, sl
 8000636:	4649      	mov	r1, r9
 8000638:	4638      	mov	r0, r7
 800063a:	f000 fb5b 	bl	8000cf4 <pxPortInitialiseStack>
 800063e:	6020      	str	r0, [r4, #0]
	if( pxCreatedTask != NULL )
 8000640:	f1b8 0f00 	cmp.w	r8, #0
 8000644:	d001      	beq.n	800064a <prvInitialiseNewTask+0x90>
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 8000646:	f8c8 4000 	str.w	r4, [r8]
}
 800064a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		pxNewTCB->pcTaskName[ 0 ] = 0x00;
 800064e:	2300      	movs	r3, #0
 8000650:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
 8000654:	e7d7      	b.n	8000606 <prvInitialiseNewTask+0x4c>
	...

08000658 <prvInitialiseTaskLists>:
{
 8000658:	b538      	push	{r3, r4, r5, lr}
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 800065a:	2400      	movs	r4, #0
 800065c:	e007      	b.n	800066e <prvInitialiseTaskLists+0x16>
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 800065e:	eb04 0284 	add.w	r2, r4, r4, lsl #2
 8000662:	0093      	lsls	r3, r2, #2
 8000664:	480e      	ldr	r0, [pc, #56]	; (80006a0 <prvInitialiseTaskLists+0x48>)
 8000666:	4418      	add	r0, r3
 8000668:	f7ff ff3f 	bl	80004ea <vListInitialise>
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 800066c:	3401      	adds	r4, #1
 800066e:	2c06      	cmp	r4, #6
 8000670:	d9f5      	bls.n	800065e <prvInitialiseTaskLists+0x6>
	vListInitialise( &xDelayedTaskList1 );
 8000672:	4d0c      	ldr	r5, [pc, #48]	; (80006a4 <prvInitialiseTaskLists+0x4c>)
 8000674:	4628      	mov	r0, r5
 8000676:	f7ff ff38 	bl	80004ea <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
 800067a:	4c0b      	ldr	r4, [pc, #44]	; (80006a8 <prvInitialiseTaskLists+0x50>)
 800067c:	4620      	mov	r0, r4
 800067e:	f7ff ff34 	bl	80004ea <vListInitialise>
	vListInitialise( &xPendingReadyList );
 8000682:	480a      	ldr	r0, [pc, #40]	; (80006ac <prvInitialiseTaskLists+0x54>)
 8000684:	f7ff ff31 	bl	80004ea <vListInitialise>
		vListInitialise( &xTasksWaitingTermination );
 8000688:	4809      	ldr	r0, [pc, #36]	; (80006b0 <prvInitialiseTaskLists+0x58>)
 800068a:	f7ff ff2e 	bl	80004ea <vListInitialise>
		vListInitialise( &xSuspendedTaskList );
 800068e:	4809      	ldr	r0, [pc, #36]	; (80006b4 <prvInitialiseTaskLists+0x5c>)
 8000690:	f7ff ff2b 	bl	80004ea <vListInitialise>
	pxDelayedTaskList = &xDelayedTaskList1;
 8000694:	4b08      	ldr	r3, [pc, #32]	; (80006b8 <prvInitialiseTaskLists+0x60>)
 8000696:	601d      	str	r5, [r3, #0]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 8000698:	4b08      	ldr	r3, [pc, #32]	; (80006bc <prvInitialiseTaskLists+0x64>)
 800069a:	601c      	str	r4, [r3, #0]
}
 800069c:	bd38      	pop	{r3, r4, r5, pc}
 800069e:	bf00      	nop
 80006a0:	2000049c 	.word	0x2000049c
 80006a4:	20000544 	.word	0x20000544
 80006a8:	20000558 	.word	0x20000558
 80006ac:	20000578 	.word	0x20000578
 80006b0:	200005a4 	.word	0x200005a4
 80006b4:	20000590 	.word	0x20000590
 80006b8:	20000494 	.word	0x20000494
 80006bc:	20000498 	.word	0x20000498

080006c0 <prvAddNewTaskToReadyList>:
{
 80006c0:	b510      	push	{r4, lr}
 80006c2:	4604      	mov	r4, r0
	taskENTER_CRITICAL();
 80006c4:	f000 fb3e 	bl	8000d44 <vPortEnterCritical>
		uxCurrentNumberOfTasks++;
 80006c8:	4a21      	ldr	r2, [pc, #132]	; (8000750 <prvAddNewTaskToReadyList+0x90>)
 80006ca:	6813      	ldr	r3, [r2, #0]
 80006cc:	3301      	adds	r3, #1
 80006ce:	6013      	str	r3, [r2, #0]
		if( pxCurrentTCB == NULL )
 80006d0:	4b20      	ldr	r3, [pc, #128]	; (8000754 <prvAddNewTaskToReadyList+0x94>)
 80006d2:	681b      	ldr	r3, [r3, #0]
 80006d4:	b15b      	cbz	r3, 80006ee <prvAddNewTaskToReadyList+0x2e>
			if( xSchedulerRunning == pdFALSE )
 80006d6:	4b20      	ldr	r3, [pc, #128]	; (8000758 <prvAddNewTaskToReadyList+0x98>)
 80006d8:	681b      	ldr	r3, [r3, #0]
 80006da:	b96b      	cbnz	r3, 80006f8 <prvAddNewTaskToReadyList+0x38>
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
 80006dc:	4b1d      	ldr	r3, [pc, #116]	; (8000754 <prvAddNewTaskToReadyList+0x94>)
 80006de:	681b      	ldr	r3, [r3, #0]
 80006e0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80006e2:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 80006e4:	429a      	cmp	r2, r3
 80006e6:	d807      	bhi.n	80006f8 <prvAddNewTaskToReadyList+0x38>
					pxCurrentTCB = pxNewTCB;
 80006e8:	4b1a      	ldr	r3, [pc, #104]	; (8000754 <prvAddNewTaskToReadyList+0x94>)
 80006ea:	601c      	str	r4, [r3, #0]
 80006ec:	e004      	b.n	80006f8 <prvAddNewTaskToReadyList+0x38>
			pxCurrentTCB = pxNewTCB;
 80006ee:	4b19      	ldr	r3, [pc, #100]	; (8000754 <prvAddNewTaskToReadyList+0x94>)
 80006f0:	601c      	str	r4, [r3, #0]
			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 80006f2:	6813      	ldr	r3, [r2, #0]
 80006f4:	2b01      	cmp	r3, #1
 80006f6:	d027      	beq.n	8000748 <prvAddNewTaskToReadyList+0x88>
		uxTaskNumber++;
 80006f8:	4a18      	ldr	r2, [pc, #96]	; (800075c <prvAddNewTaskToReadyList+0x9c>)
 80006fa:	6813      	ldr	r3, [r2, #0]
 80006fc:	3301      	adds	r3, #1
 80006fe:	6013      	str	r3, [r2, #0]
			pxNewTCB->uxTCBNumber = uxTaskNumber;
 8000700:	6463      	str	r3, [r4, #68]	; 0x44
		prvAddTaskToReadyList( pxNewTCB );
 8000702:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8000704:	2201      	movs	r2, #1
 8000706:	409a      	lsls	r2, r3
 8000708:	4915      	ldr	r1, [pc, #84]	; (8000760 <prvAddNewTaskToReadyList+0xa0>)
 800070a:	6808      	ldr	r0, [r1, #0]
 800070c:	4302      	orrs	r2, r0
 800070e:	600a      	str	r2, [r1, #0]
 8000710:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8000714:	009a      	lsls	r2, r3, #2
 8000716:	1d21      	adds	r1, r4, #4
 8000718:	4812      	ldr	r0, [pc, #72]	; (8000764 <prvAddNewTaskToReadyList+0xa4>)
 800071a:	4410      	add	r0, r2
 800071c:	f7ff fef3 	bl	8000506 <vListInsertEnd>
	taskEXIT_CRITICAL();
 8000720:	f000 fb32 	bl	8000d88 <vPortExitCritical>
	if( xSchedulerRunning != pdFALSE )
 8000724:	4b0c      	ldr	r3, [pc, #48]	; (8000758 <prvAddNewTaskToReadyList+0x98>)
 8000726:	681b      	ldr	r3, [r3, #0]
 8000728:	b16b      	cbz	r3, 8000746 <prvAddNewTaskToReadyList+0x86>
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
 800072a:	4b0a      	ldr	r3, [pc, #40]	; (8000754 <prvAddNewTaskToReadyList+0x94>)
 800072c:	681b      	ldr	r3, [r3, #0]
 800072e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8000730:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8000732:	429a      	cmp	r2, r3
 8000734:	d207      	bcs.n	8000746 <prvAddNewTaskToReadyList+0x86>
			taskYIELD_IF_USING_PREEMPTION();
 8000736:	4b0c      	ldr	r3, [pc, #48]	; (8000768 <prvAddNewTaskToReadyList+0xa8>)
 8000738:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800073c:	601a      	str	r2, [r3, #0]
 800073e:	f3bf 8f4f 	dsb	sy
 8000742:	f3bf 8f6f 	isb	sy
}
 8000746:	bd10      	pop	{r4, pc}
				prvInitialiseTaskLists();
 8000748:	f7ff ff86 	bl	8000658 <prvInitialiseTaskLists>
 800074c:	e7d4      	b.n	80006f8 <prvAddNewTaskToReadyList+0x38>
 800074e:	bf00      	nop
 8000750:	2000052c 	.word	0x2000052c
 8000754:	20000490 	.word	0x20000490
 8000758:	2000058c 	.word	0x2000058c
 800075c:	2000053c 	.word	0x2000053c
 8000760:	20000540 	.word	0x20000540
 8000764:	2000049c 	.word	0x2000049c
 8000768:	e000ed04 	.word	0xe000ed04

0800076c <prvCheckTasksWaitingTermination>:
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 800076c:	4b0f      	ldr	r3, [pc, #60]	; (80007ac <prvCheckTasksWaitingTermination+0x40>)
 800076e:	681b      	ldr	r3, [r3, #0]
 8000770:	b1d3      	cbz	r3, 80007a8 <prvCheckTasksWaitingTermination+0x3c>
{
 8000772:	b510      	push	{r4, lr}
			taskENTER_CRITICAL();
 8000774:	f000 fae6 	bl	8000d44 <vPortEnterCritical>
				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8000778:	4b0d      	ldr	r3, [pc, #52]	; (80007b0 <prvCheckTasksWaitingTermination+0x44>)
 800077a:	68db      	ldr	r3, [r3, #12]
 800077c:	68dc      	ldr	r4, [r3, #12]
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 800077e:	1d20      	adds	r0, r4, #4
 8000780:	f7ff fee7 	bl	8000552 <uxListRemove>
				--uxCurrentNumberOfTasks;
 8000784:	4a0b      	ldr	r2, [pc, #44]	; (80007b4 <prvCheckTasksWaitingTermination+0x48>)
 8000786:	6813      	ldr	r3, [r2, #0]
 8000788:	3b01      	subs	r3, #1
 800078a:	6013      	str	r3, [r2, #0]
				--uxDeletedTasksWaitingCleanUp;
 800078c:	4a07      	ldr	r2, [pc, #28]	; (80007ac <prvCheckTasksWaitingTermination+0x40>)
 800078e:	6813      	ldr	r3, [r2, #0]
 8000790:	3b01      	subs	r3, #1
 8000792:	6013      	str	r3, [r2, #0]
			taskEXIT_CRITICAL();
 8000794:	f000 faf8 	bl	8000d88 <vPortExitCritical>
			prvDeleteTCB( pxTCB );
 8000798:	4620      	mov	r0, r4
 800079a:	f7ff ff05 	bl	80005a8 <prvDeleteTCB>
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 800079e:	4b03      	ldr	r3, [pc, #12]	; (80007ac <prvCheckTasksWaitingTermination+0x40>)
 80007a0:	681b      	ldr	r3, [r3, #0]
 80007a2:	2b00      	cmp	r3, #0
 80007a4:	d1e6      	bne.n	8000774 <prvCheckTasksWaitingTermination+0x8>
}
 80007a6:	bd10      	pop	{r4, pc}
 80007a8:	4770      	bx	lr
 80007aa:	bf00      	nop
 80007ac:	20000530 	.word	0x20000530
 80007b0:	200005a4 	.word	0x200005a4
 80007b4:	2000052c 	.word	0x2000052c

080007b8 <prvIdleTask>:
{
 80007b8:	b508      	push	{r3, lr}
		prvCheckTasksWaitingTermination();
 80007ba:	f7ff ffd7 	bl	800076c <prvCheckTasksWaitingTermination>
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 80007be:	4b06      	ldr	r3, [pc, #24]	; (80007d8 <prvIdleTask+0x20>)
 80007c0:	681b      	ldr	r3, [r3, #0]
 80007c2:	2b01      	cmp	r3, #1
 80007c4:	d9f9      	bls.n	80007ba <prvIdleTask+0x2>
				taskYIELD();
 80007c6:	4b05      	ldr	r3, [pc, #20]	; (80007dc <prvIdleTask+0x24>)
 80007c8:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80007cc:	601a      	str	r2, [r3, #0]
 80007ce:	f3bf 8f4f 	dsb	sy
 80007d2:	f3bf 8f6f 	isb	sy
 80007d6:	e7f0      	b.n	80007ba <prvIdleTask+0x2>
 80007d8:	2000049c 	.word	0x2000049c
 80007dc:	e000ed04 	.word	0xe000ed04

080007e0 <prvAddCurrentTaskToDelayedList>:
	}
#endif
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
 80007e0:	b570      	push	{r4, r5, r6, lr}
 80007e2:	4604      	mov	r4, r0
 80007e4:	460e      	mov	r6, r1
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
 80007e6:	4b1d      	ldr	r3, [pc, #116]	; (800085c <prvAddCurrentTaskToDelayedList+0x7c>)
 80007e8:	681d      	ldr	r5, [r3, #0]
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 80007ea:	4b1d      	ldr	r3, [pc, #116]	; (8000860 <prvAddCurrentTaskToDelayedList+0x80>)
 80007ec:	6818      	ldr	r0, [r3, #0]
 80007ee:	3004      	adds	r0, #4
 80007f0:	f7ff feaf 	bl	8000552 <uxListRemove>
 80007f4:	b950      	cbnz	r0, 800080c <prvAddCurrentTaskToDelayedList+0x2c>
	{
		/* The current task must be in a ready list, so there is no need to
		check, and the port reset macro can be called directly. */
		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority ); /*lint !e931 pxCurrentTCB cannot change as it is the calling task.  pxCurrentTCB->uxPriority and uxTopReadyPriority cannot change as called with scheduler suspended or in a critical section. */
 80007f6:	4b1a      	ldr	r3, [pc, #104]	; (8000860 <prvAddCurrentTaskToDelayedList+0x80>)
 80007f8:	681b      	ldr	r3, [r3, #0]
 80007fa:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80007fc:	2301      	movs	r3, #1
 80007fe:	fa03 f202 	lsl.w	r2, r3, r2
 8000802:	4918      	ldr	r1, [pc, #96]	; (8000864 <prvAddCurrentTaskToDelayedList+0x84>)
 8000804:	680b      	ldr	r3, [r1, #0]
 8000806:	ea23 0302 	bic.w	r3, r3, r2
 800080a:	600b      	str	r3, [r1, #0]
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 800080c:	f1b4 3fff 	cmp.w	r4, #4294967295
 8000810:	d013      	beq.n	800083a <prvAddCurrentTaskToDelayedList+0x5a>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
 8000812:	442c      	add	r4, r5

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 8000814:	4b12      	ldr	r3, [pc, #72]	; (8000860 <prvAddCurrentTaskToDelayedList+0x80>)
 8000816:	681b      	ldr	r3, [r3, #0]
 8000818:	605c      	str	r4, [r3, #4]

			if( xTimeToWake < xConstTickCount )
 800081a:	42a5      	cmp	r5, r4
 800081c:	d816      	bhi.n	800084c <prvAddCurrentTaskToDelayedList+0x6c>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 800081e:	4b12      	ldr	r3, [pc, #72]	; (8000868 <prvAddCurrentTaskToDelayedList+0x88>)
 8000820:	6818      	ldr	r0, [r3, #0]
 8000822:	4b0f      	ldr	r3, [pc, #60]	; (8000860 <prvAddCurrentTaskToDelayedList+0x80>)
 8000824:	6819      	ldr	r1, [r3, #0]
 8000826:	3104      	adds	r1, #4
 8000828:	f7ff fe79 	bl	800051e <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
 800082c:	4b0f      	ldr	r3, [pc, #60]	; (800086c <prvAddCurrentTaskToDelayedList+0x8c>)
 800082e:	681b      	ldr	r3, [r3, #0]
 8000830:	42a3      	cmp	r3, r4
 8000832:	d912      	bls.n	800085a <prvAddCurrentTaskToDelayedList+0x7a>
				{
					xNextTaskUnblockTime = xTimeToWake;
 8000834:	4b0d      	ldr	r3, [pc, #52]	; (800086c <prvAddCurrentTaskToDelayedList+0x8c>)
 8000836:	601c      	str	r4, [r3, #0]

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
 8000838:	e00f      	b.n	800085a <prvAddCurrentTaskToDelayedList+0x7a>
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 800083a:	2e00      	cmp	r6, #0
 800083c:	d0e9      	beq.n	8000812 <prvAddCurrentTaskToDelayedList+0x32>
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 800083e:	4b08      	ldr	r3, [pc, #32]	; (8000860 <prvAddCurrentTaskToDelayedList+0x80>)
 8000840:	6819      	ldr	r1, [r3, #0]
 8000842:	3104      	adds	r1, #4
 8000844:	480a      	ldr	r0, [pc, #40]	; (8000870 <prvAddCurrentTaskToDelayedList+0x90>)
 8000846:	f7ff fe5e 	bl	8000506 <vListInsertEnd>
 800084a:	e006      	b.n	800085a <prvAddCurrentTaskToDelayedList+0x7a>
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 800084c:	4b09      	ldr	r3, [pc, #36]	; (8000874 <prvAddCurrentTaskToDelayedList+0x94>)
 800084e:	6818      	ldr	r0, [r3, #0]
 8000850:	4b03      	ldr	r3, [pc, #12]	; (8000860 <prvAddCurrentTaskToDelayedList+0x80>)
 8000852:	6819      	ldr	r1, [r3, #0]
 8000854:	3104      	adds	r1, #4
 8000856:	f7ff fe62 	bl	800051e <vListInsert>
}
 800085a:	bd70      	pop	{r4, r5, r6, pc}
 800085c:	200005b8 	.word	0x200005b8
 8000860:	20000490 	.word	0x20000490
 8000864:	20000540 	.word	0x20000540
 8000868:	20000494 	.word	0x20000494
 800086c:	20000570 	.word	0x20000570
 8000870:	20000590 	.word	0x20000590
 8000874:	20000498 	.word	0x20000498

08000878 <xTaskCreate>:
	{
 8000878:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800087c:	b085      	sub	sp, #20
 800087e:	4607      	mov	r7, r0
 8000880:	4688      	mov	r8, r1
 8000882:	4615      	mov	r5, r2
 8000884:	4699      	mov	r9, r3
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
 8000886:	0090      	lsls	r0, r2, #2
 8000888:	f000 fbe4 	bl	8001054 <pvPortMalloc>
			if( pxStack != NULL )
 800088c:	b1f8      	cbz	r0, 80008ce <xTaskCreate+0x56>
 800088e:	4606      	mov	r6, r0
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
 8000890:	2060      	movs	r0, #96	; 0x60
 8000892:	f000 fbdf 	bl	8001054 <pvPortMalloc>
				if( pxNewTCB != NULL )
 8000896:	4604      	mov	r4, r0
 8000898:	b1a8      	cbz	r0, 80008c6 <xTaskCreate+0x4e>
					pxNewTCB->pxStack = pxStack;
 800089a:	6306      	str	r6, [r0, #48]	; 0x30
		if( pxNewTCB != NULL )
 800089c:	b1d4      	cbz	r4, 80008d4 <xTaskCreate+0x5c>
			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
 800089e:	2300      	movs	r3, #0
 80008a0:	9303      	str	r3, [sp, #12]
 80008a2:	9402      	str	r4, [sp, #8]
 80008a4:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80008a6:	9301      	str	r3, [sp, #4]
 80008a8:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80008aa:	9300      	str	r3, [sp, #0]
 80008ac:	464b      	mov	r3, r9
 80008ae:	462a      	mov	r2, r5
 80008b0:	4641      	mov	r1, r8
 80008b2:	4638      	mov	r0, r7
 80008b4:	f7ff fe81 	bl	80005ba <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
 80008b8:	4620      	mov	r0, r4
 80008ba:	f7ff ff01 	bl	80006c0 <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
 80008be:	2001      	movs	r0, #1
	}
 80008c0:	b005      	add	sp, #20
 80008c2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
					vPortFree( pxStack );
 80008c6:	4630      	mov	r0, r6
 80008c8:	f000 fc48 	bl	800115c <vPortFree>
 80008cc:	e7e6      	b.n	800089c <xTaskCreate+0x24>
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 80008ce:	f04f 30ff 	mov.w	r0, #4294967295
 80008d2:	e7f5      	b.n	80008c0 <xTaskCreate+0x48>
 80008d4:	f04f 30ff 	mov.w	r0, #4294967295
		return xReturn;
 80008d8:	e7f2      	b.n	80008c0 <xTaskCreate+0x48>
	...

080008dc <vTaskStartScheduler>:
{
 80008dc:	b500      	push	{lr}
 80008de:	b083      	sub	sp, #12
		xReturn = xTaskCreate(	prvIdleTask,
 80008e0:	4b18      	ldr	r3, [pc, #96]	; (8000944 <vTaskStartScheduler+0x68>)
 80008e2:	9301      	str	r3, [sp, #4]
 80008e4:	2300      	movs	r3, #0
 80008e6:	9300      	str	r3, [sp, #0]
 80008e8:	2280      	movs	r2, #128	; 0x80
 80008ea:	4917      	ldr	r1, [pc, #92]	; (8000948 <vTaskStartScheduler+0x6c>)
 80008ec:	4817      	ldr	r0, [pc, #92]	; (800094c <vTaskStartScheduler+0x70>)
 80008ee:	f7ff ffc3 	bl	8000878 <xTaskCreate>
	if( xReturn == pdPASS )
 80008f2:	2801      	cmp	r0, #1
 80008f4:	d005      	beq.n	8000902 <vTaskStartScheduler+0x26>
		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
 80008f6:	f1b0 3fff 	cmp.w	r0, #4294967295
 80008fa:	d019      	beq.n	8000930 <vTaskStartScheduler+0x54>
}
 80008fc:	b003      	add	sp, #12
 80008fe:	f85d fb04 	ldr.w	pc, [sp], #4

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
 8000902:	f04f 0350 	mov.w	r3, #80	; 0x50
 8000906:	f383 8811 	msr	BASEPRI, r3
 800090a:	f3bf 8f6f 	isb	sy
 800090e:	f3bf 8f4f 	dsb	sy
		xNextTaskUnblockTime = portMAX_DELAY;
 8000912:	4b0f      	ldr	r3, [pc, #60]	; (8000950 <vTaskStartScheduler+0x74>)
 8000914:	f04f 32ff 	mov.w	r2, #4294967295
 8000918:	601a      	str	r2, [r3, #0]
		xSchedulerRunning = pdTRUE;
 800091a:	4b0e      	ldr	r3, [pc, #56]	; (8000954 <vTaskStartScheduler+0x78>)
 800091c:	2201      	movs	r2, #1
 800091e:	601a      	str	r2, [r3, #0]
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
 8000920:	4b0d      	ldr	r3, [pc, #52]	; (8000958 <vTaskStartScheduler+0x7c>)
 8000922:	2200      	movs	r2, #0
 8000924:	601a      	str	r2, [r3, #0]
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
 8000926:	f000 fc7f 	bl	8001228 <prf_timer_osmeasurer_init>
		if( xPortStartScheduler() != pdFALSE )
 800092a:	f000 faad 	bl	8000e88 <xPortStartScheduler>
 800092e:	e7e5      	b.n	80008fc <vTaskStartScheduler+0x20>
 8000930:	f04f 0350 	mov.w	r3, #80	; 0x50
 8000934:	f383 8811 	msr	BASEPRI, r3
 8000938:	f3bf 8f6f 	isb	sy
 800093c:	f3bf 8f4f 	dsb	sy
 8000940:	e7fe      	b.n	8000940 <vTaskStartScheduler+0x64>
 8000942:	bf00      	nop
 8000944:	2000056c 	.word	0x2000056c
 8000948:	08001440 	.word	0x08001440
 800094c:	080007b9 	.word	0x080007b9
 8000950:	20000570 	.word	0x20000570
 8000954:	2000058c 	.word	0x2000058c
 8000958:	200005b8 	.word	0x200005b8

0800095c <vTaskSuspendAll>:
	++uxSchedulerSuspended;
 800095c:	4a02      	ldr	r2, [pc, #8]	; (8000968 <vTaskSuspendAll+0xc>)
 800095e:	6813      	ldr	r3, [r2, #0]
 8000960:	3301      	adds	r3, #1
 8000962:	6013      	str	r3, [r2, #0]
}
 8000964:	4770      	bx	lr
 8000966:	bf00      	nop
 8000968:	20000538 	.word	0x20000538

0800096c <xTaskIncrementTick>:
{
 800096c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 800096e:	4b3a      	ldr	r3, [pc, #232]	; (8000a58 <xTaskIncrementTick+0xec>)
 8000970:	681b      	ldr	r3, [r3, #0]
 8000972:	2b00      	cmp	r3, #0
 8000974:	d164      	bne.n	8000a40 <xTaskIncrementTick+0xd4>
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
 8000976:	4b39      	ldr	r3, [pc, #228]	; (8000a5c <xTaskIncrementTick+0xf0>)
 8000978:	681d      	ldr	r5, [r3, #0]
 800097a:	3501      	adds	r5, #1
		xTickCount = xConstTickCount;
 800097c:	601d      	str	r5, [r3, #0]
		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
 800097e:	b9c5      	cbnz	r5, 80009b2 <xTaskIncrementTick+0x46>
			taskSWITCH_DELAYED_LISTS();
 8000980:	4b37      	ldr	r3, [pc, #220]	; (8000a60 <xTaskIncrementTick+0xf4>)
 8000982:	681b      	ldr	r3, [r3, #0]
 8000984:	681b      	ldr	r3, [r3, #0]
 8000986:	b143      	cbz	r3, 800099a <xTaskIncrementTick+0x2e>
 8000988:	f04f 0350 	mov.w	r3, #80	; 0x50
 800098c:	f383 8811 	msr	BASEPRI, r3
 8000990:	f3bf 8f6f 	isb	sy
 8000994:	f3bf 8f4f 	dsb	sy
 8000998:	e7fe      	b.n	8000998 <xTaskIncrementTick+0x2c>
 800099a:	4a31      	ldr	r2, [pc, #196]	; (8000a60 <xTaskIncrementTick+0xf4>)
 800099c:	6811      	ldr	r1, [r2, #0]
 800099e:	4b31      	ldr	r3, [pc, #196]	; (8000a64 <xTaskIncrementTick+0xf8>)
 80009a0:	6818      	ldr	r0, [r3, #0]
 80009a2:	6010      	str	r0, [r2, #0]
 80009a4:	6019      	str	r1, [r3, #0]
 80009a6:	4a30      	ldr	r2, [pc, #192]	; (8000a68 <xTaskIncrementTick+0xfc>)
 80009a8:	6813      	ldr	r3, [r2, #0]
 80009aa:	3301      	adds	r3, #1
 80009ac:	6013      	str	r3, [r2, #0]
 80009ae:	f7ff fde5 	bl	800057c <prvResetNextTaskUnblockTime>
		if( xConstTickCount >= xNextTaskUnblockTime )
 80009b2:	4b2e      	ldr	r3, [pc, #184]	; (8000a6c <xTaskIncrementTick+0x100>)
 80009b4:	681b      	ldr	r3, [r3, #0]
 80009b6:	42ab      	cmp	r3, r5
 80009b8:	d938      	bls.n	8000a2c <xTaskIncrementTick+0xc0>
BaseType_t xSwitchRequired = pdFALSE;
 80009ba:	2400      	movs	r4, #0
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
 80009bc:	4b2c      	ldr	r3, [pc, #176]	; (8000a70 <xTaskIncrementTick+0x104>)
 80009be:	681b      	ldr	r3, [r3, #0]
 80009c0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80009c2:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 80009c6:	009a      	lsls	r2, r3, #2
 80009c8:	4b2a      	ldr	r3, [pc, #168]	; (8000a74 <xTaskIncrementTick+0x108>)
 80009ca:	589b      	ldr	r3, [r3, r2]
 80009cc:	2b01      	cmp	r3, #1
 80009ce:	d93c      	bls.n	8000a4a <xTaskIncrementTick+0xde>
				xSwitchRequired = pdTRUE;
 80009d0:	2401      	movs	r4, #1
 80009d2:	e03a      	b.n	8000a4a <xTaskIncrementTick+0xde>
							xSwitchRequired = pdTRUE;
 80009d4:	2401      	movs	r4, #1
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 80009d6:	4b22      	ldr	r3, [pc, #136]	; (8000a60 <xTaskIncrementTick+0xf4>)
 80009d8:	681b      	ldr	r3, [r3, #0]
 80009da:	681b      	ldr	r3, [r3, #0]
 80009dc:	b343      	cbz	r3, 8000a30 <xTaskIncrementTick+0xc4>
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 80009de:	4b20      	ldr	r3, [pc, #128]	; (8000a60 <xTaskIncrementTick+0xf4>)
 80009e0:	681b      	ldr	r3, [r3, #0]
 80009e2:	68db      	ldr	r3, [r3, #12]
 80009e4:	68de      	ldr	r6, [r3, #12]
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 80009e6:	6873      	ldr	r3, [r6, #4]
					if( xConstTickCount < xItemValue )
 80009e8:	429d      	cmp	r5, r3
 80009ea:	d326      	bcc.n	8000a3a <xTaskIncrementTick+0xce>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 80009ec:	1d37      	adds	r7, r6, #4
 80009ee:	4638      	mov	r0, r7
 80009f0:	f7ff fdaf 	bl	8000552 <uxListRemove>
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 80009f4:	6ab3      	ldr	r3, [r6, #40]	; 0x28
 80009f6:	b11b      	cbz	r3, 8000a00 <xTaskIncrementTick+0x94>
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 80009f8:	f106 0018 	add.w	r0, r6, #24
 80009fc:	f7ff fda9 	bl	8000552 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 8000a00:	6af3      	ldr	r3, [r6, #44]	; 0x2c
 8000a02:	2201      	movs	r2, #1
 8000a04:	409a      	lsls	r2, r3
 8000a06:	491c      	ldr	r1, [pc, #112]	; (8000a78 <xTaskIncrementTick+0x10c>)
 8000a08:	6808      	ldr	r0, [r1, #0]
 8000a0a:	4302      	orrs	r2, r0
 8000a0c:	600a      	str	r2, [r1, #0]
 8000a0e:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8000a12:	009a      	lsls	r2, r3, #2
 8000a14:	4639      	mov	r1, r7
 8000a16:	4817      	ldr	r0, [pc, #92]	; (8000a74 <xTaskIncrementTick+0x108>)
 8000a18:	4410      	add	r0, r2
 8000a1a:	f7ff fd74 	bl	8000506 <vListInsertEnd>
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8000a1e:	6af2      	ldr	r2, [r6, #44]	; 0x2c
 8000a20:	4b13      	ldr	r3, [pc, #76]	; (8000a70 <xTaskIncrementTick+0x104>)
 8000a22:	681b      	ldr	r3, [r3, #0]
 8000a24:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8000a26:	429a      	cmp	r2, r3
 8000a28:	d2d4      	bcs.n	80009d4 <xTaskIncrementTick+0x68>
 8000a2a:	e7d4      	b.n	80009d6 <xTaskIncrementTick+0x6a>
BaseType_t xSwitchRequired = pdFALSE;
 8000a2c:	2400      	movs	r4, #0
 8000a2e:	e7d2      	b.n	80009d6 <xTaskIncrementTick+0x6a>
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8000a30:	4b0e      	ldr	r3, [pc, #56]	; (8000a6c <xTaskIncrementTick+0x100>)
 8000a32:	f04f 32ff 	mov.w	r2, #4294967295
 8000a36:	601a      	str	r2, [r3, #0]
					break;
 8000a38:	e7c0      	b.n	80009bc <xTaskIncrementTick+0x50>
						xNextTaskUnblockTime = xItemValue;
 8000a3a:	4a0c      	ldr	r2, [pc, #48]	; (8000a6c <xTaskIncrementTick+0x100>)
 8000a3c:	6013      	str	r3, [r2, #0]
						break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks. */
 8000a3e:	e7bd      	b.n	80009bc <xTaskIncrementTick+0x50>
		++uxPendedTicks;
 8000a40:	4a0e      	ldr	r2, [pc, #56]	; (8000a7c <xTaskIncrementTick+0x110>)
 8000a42:	6813      	ldr	r3, [r2, #0]
 8000a44:	3301      	adds	r3, #1
 8000a46:	6013      	str	r3, [r2, #0]
BaseType_t xSwitchRequired = pdFALSE;
 8000a48:	2400      	movs	r4, #0
		if( xYieldPending != pdFALSE )
 8000a4a:	4b0d      	ldr	r3, [pc, #52]	; (8000a80 <xTaskIncrementTick+0x114>)
 8000a4c:	681b      	ldr	r3, [r3, #0]
 8000a4e:	b103      	cbz	r3, 8000a52 <xTaskIncrementTick+0xe6>
			xSwitchRequired = pdTRUE;
 8000a50:	2401      	movs	r4, #1
}
 8000a52:	4620      	mov	r0, r4
 8000a54:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8000a56:	bf00      	nop
 8000a58:	20000538 	.word	0x20000538
 8000a5c:	200005b8 	.word	0x200005b8
 8000a60:	20000494 	.word	0x20000494
 8000a64:	20000498 	.word	0x20000498
 8000a68:	20000574 	.word	0x20000574
 8000a6c:	20000570 	.word	0x20000570
 8000a70:	20000490 	.word	0x20000490
 8000a74:	2000049c 	.word	0x2000049c
 8000a78:	20000540 	.word	0x20000540
 8000a7c:	20000534 	.word	0x20000534
 8000a80:	200005bc 	.word	0x200005bc

08000a84 <xTaskResumeAll>:
{
 8000a84:	b538      	push	{r3, r4, r5, lr}
	configASSERT( uxSchedulerSuspended );
 8000a86:	4b33      	ldr	r3, [pc, #204]	; (8000b54 <xTaskResumeAll+0xd0>)
 8000a88:	681b      	ldr	r3, [r3, #0]
 8000a8a:	b943      	cbnz	r3, 8000a9e <xTaskResumeAll+0x1a>
 8000a8c:	f04f 0350 	mov.w	r3, #80	; 0x50
 8000a90:	f383 8811 	msr	BASEPRI, r3
 8000a94:	f3bf 8f6f 	isb	sy
 8000a98:	f3bf 8f4f 	dsb	sy
 8000a9c:	e7fe      	b.n	8000a9c <xTaskResumeAll+0x18>
	taskENTER_CRITICAL();
 8000a9e:	f000 f951 	bl	8000d44 <vPortEnterCritical>
		--uxSchedulerSuspended;
 8000aa2:	4b2c      	ldr	r3, [pc, #176]	; (8000b54 <xTaskResumeAll+0xd0>)
 8000aa4:	681a      	ldr	r2, [r3, #0]
 8000aa6:	3a01      	subs	r2, #1
 8000aa8:	601a      	str	r2, [r3, #0]
		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8000aaa:	681b      	ldr	r3, [r3, #0]
 8000aac:	2b00      	cmp	r3, #0
 8000aae:	d14d      	bne.n	8000b4c <xTaskResumeAll+0xc8>
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 8000ab0:	4b29      	ldr	r3, [pc, #164]	; (8000b58 <xTaskResumeAll+0xd4>)
 8000ab2:	681b      	ldr	r3, [r3, #0]
 8000ab4:	b923      	cbnz	r3, 8000ac0 <xTaskResumeAll+0x3c>
BaseType_t xAlreadyYielded = pdFALSE;
 8000ab6:	2400      	movs	r4, #0
	taskEXIT_CRITICAL();
 8000ab8:	f000 f966 	bl	8000d88 <vPortExitCritical>
}
 8000abc:	4620      	mov	r0, r4
 8000abe:	bd38      	pop	{r3, r4, r5, pc}
TCB_t *pxTCB = NULL;
 8000ac0:	2400      	movs	r4, #0
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 8000ac2:	4b26      	ldr	r3, [pc, #152]	; (8000b5c <xTaskResumeAll+0xd8>)
 8000ac4:	681b      	ldr	r3, [r3, #0]
 8000ac6:	b31b      	cbz	r3, 8000b10 <xTaskResumeAll+0x8c>
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8000ac8:	4b24      	ldr	r3, [pc, #144]	; (8000b5c <xTaskResumeAll+0xd8>)
 8000aca:	68db      	ldr	r3, [r3, #12]
 8000acc:	68dc      	ldr	r4, [r3, #12]
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 8000ace:	f104 0018 	add.w	r0, r4, #24
 8000ad2:	f7ff fd3e 	bl	8000552 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8000ad6:	1d25      	adds	r5, r4, #4
 8000ad8:	4628      	mov	r0, r5
 8000ada:	f7ff fd3a 	bl	8000552 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 8000ade:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8000ae0:	2201      	movs	r2, #1
 8000ae2:	409a      	lsls	r2, r3
 8000ae4:	491e      	ldr	r1, [pc, #120]	; (8000b60 <xTaskResumeAll+0xdc>)
 8000ae6:	6808      	ldr	r0, [r1, #0]
 8000ae8:	4302      	orrs	r2, r0
 8000aea:	600a      	str	r2, [r1, #0]
 8000aec:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8000af0:	009a      	lsls	r2, r3, #2
 8000af2:	4629      	mov	r1, r5
 8000af4:	481b      	ldr	r0, [pc, #108]	; (8000b64 <xTaskResumeAll+0xe0>)
 8000af6:	4410      	add	r0, r2
 8000af8:	f7ff fd05 	bl	8000506 <vListInsertEnd>
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8000afc:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8000afe:	4b1a      	ldr	r3, [pc, #104]	; (8000b68 <xTaskResumeAll+0xe4>)
 8000b00:	681b      	ldr	r3, [r3, #0]
 8000b02:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8000b04:	429a      	cmp	r2, r3
 8000b06:	d3dc      	bcc.n	8000ac2 <xTaskResumeAll+0x3e>
						xYieldPending = pdTRUE;
 8000b08:	4b18      	ldr	r3, [pc, #96]	; (8000b6c <xTaskResumeAll+0xe8>)
 8000b0a:	2201      	movs	r2, #1
 8000b0c:	601a      	str	r2, [r3, #0]
 8000b0e:	e7d8      	b.n	8000ac2 <xTaskResumeAll+0x3e>
				if( pxTCB != NULL )
 8000b10:	b10c      	cbz	r4, 8000b16 <xTaskResumeAll+0x92>
					prvResetNextTaskUnblockTime();
 8000b12:	f7ff fd33 	bl	800057c <prvResetNextTaskUnblockTime>
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
 8000b16:	4b16      	ldr	r3, [pc, #88]	; (8000b70 <xTaskResumeAll+0xec>)
 8000b18:	681c      	ldr	r4, [r3, #0]
					if( uxPendedCounts > ( UBaseType_t ) 0U )
 8000b1a:	b154      	cbz	r4, 8000b32 <xTaskResumeAll+0xae>
							if( xTaskIncrementTick() != pdFALSE )
 8000b1c:	f7ff ff26 	bl	800096c <xTaskIncrementTick>
 8000b20:	b110      	cbz	r0, 8000b28 <xTaskResumeAll+0xa4>
								xYieldPending = pdTRUE;
 8000b22:	4b12      	ldr	r3, [pc, #72]	; (8000b6c <xTaskResumeAll+0xe8>)
 8000b24:	2201      	movs	r2, #1
 8000b26:	601a      	str	r2, [r3, #0]
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
 8000b28:	3c01      	subs	r4, #1
 8000b2a:	d1f7      	bne.n	8000b1c <xTaskResumeAll+0x98>
						uxPendedTicks = 0;
 8000b2c:	4b10      	ldr	r3, [pc, #64]	; (8000b70 <xTaskResumeAll+0xec>)
 8000b2e:	2200      	movs	r2, #0
 8000b30:	601a      	str	r2, [r3, #0]
				if( xYieldPending != pdFALSE )
 8000b32:	4b0e      	ldr	r3, [pc, #56]	; (8000b6c <xTaskResumeAll+0xe8>)
 8000b34:	681b      	ldr	r3, [r3, #0]
 8000b36:	b15b      	cbz	r3, 8000b50 <xTaskResumeAll+0xcc>
					taskYIELD_IF_USING_PREEMPTION();
 8000b38:	4b0e      	ldr	r3, [pc, #56]	; (8000b74 <xTaskResumeAll+0xf0>)
 8000b3a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8000b3e:	601a      	str	r2, [r3, #0]
 8000b40:	f3bf 8f4f 	dsb	sy
 8000b44:	f3bf 8f6f 	isb	sy
						xAlreadyYielded = pdTRUE;
 8000b48:	2401      	movs	r4, #1
 8000b4a:	e7b5      	b.n	8000ab8 <xTaskResumeAll+0x34>
BaseType_t xAlreadyYielded = pdFALSE;
 8000b4c:	2400      	movs	r4, #0
 8000b4e:	e7b3      	b.n	8000ab8 <xTaskResumeAll+0x34>
 8000b50:	2400      	movs	r4, #0
 8000b52:	e7b1      	b.n	8000ab8 <xTaskResumeAll+0x34>
 8000b54:	20000538 	.word	0x20000538
 8000b58:	2000052c 	.word	0x2000052c
 8000b5c:	20000578 	.word	0x20000578
 8000b60:	20000540 	.word	0x20000540
 8000b64:	2000049c 	.word	0x2000049c
 8000b68:	20000490 	.word	0x20000490
 8000b6c:	200005bc 	.word	0x200005bc
 8000b70:	20000534 	.word	0x20000534
 8000b74:	e000ed04 	.word	0xe000ed04

08000b78 <vTaskDelay>:
	{
 8000b78:	b510      	push	{r4, lr}
		if( xTicksToDelay > ( TickType_t ) 0U )
 8000b7a:	b1a8      	cbz	r0, 8000ba8 <vTaskDelay+0x30>
 8000b7c:	4604      	mov	r4, r0
			configASSERT( uxSchedulerSuspended == 0 );
 8000b7e:	4b0f      	ldr	r3, [pc, #60]	; (8000bbc <vTaskDelay+0x44>)
 8000b80:	681b      	ldr	r3, [r3, #0]
 8000b82:	b143      	cbz	r3, 8000b96 <vTaskDelay+0x1e>
 8000b84:	f04f 0350 	mov.w	r3, #80	; 0x50
 8000b88:	f383 8811 	msr	BASEPRI, r3
 8000b8c:	f3bf 8f6f 	isb	sy
 8000b90:	f3bf 8f4f 	dsb	sy
 8000b94:	e7fe      	b.n	8000b94 <vTaskDelay+0x1c>
			vTaskSuspendAll();
 8000b96:	f7ff fee1 	bl	800095c <vTaskSuspendAll>
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
 8000b9a:	2100      	movs	r1, #0
 8000b9c:	4620      	mov	r0, r4
 8000b9e:	f7ff fe1f 	bl	80007e0 <prvAddCurrentTaskToDelayedList>
			xAlreadyYielded = xTaskResumeAll();
 8000ba2:	f7ff ff6f 	bl	8000a84 <xTaskResumeAll>
		if( xAlreadyYielded == pdFALSE )
 8000ba6:	b938      	cbnz	r0, 8000bb8 <vTaskDelay+0x40>
			portYIELD_WITHIN_API();
 8000ba8:	4b05      	ldr	r3, [pc, #20]	; (8000bc0 <vTaskDelay+0x48>)
 8000baa:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8000bae:	601a      	str	r2, [r3, #0]
 8000bb0:	f3bf 8f4f 	dsb	sy
 8000bb4:	f3bf 8f6f 	isb	sy
	}
 8000bb8:	bd10      	pop	{r4, pc}
 8000bba:	bf00      	nop
 8000bbc:	20000538 	.word	0x20000538
 8000bc0:	e000ed04 	.word	0xe000ed04

08000bc4 <vTaskSwitchContext>:
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 8000bc4:	4b26      	ldr	r3, [pc, #152]	; (8000c60 <vTaskSwitchContext+0x9c>)
 8000bc6:	681b      	ldr	r3, [r3, #0]
 8000bc8:	b11b      	cbz	r3, 8000bd2 <vTaskSwitchContext+0xe>
		xYieldPending = pdTRUE;
 8000bca:	4b26      	ldr	r3, [pc, #152]	; (8000c64 <vTaskSwitchContext+0xa0>)
 8000bcc:	2201      	movs	r2, #1
 8000bce:	601a      	str	r2, [r3, #0]
 8000bd0:	4770      	bx	lr
{
 8000bd2:	b510      	push	{r4, lr}
		xYieldPending = pdFALSE;
 8000bd4:	4b23      	ldr	r3, [pc, #140]	; (8000c64 <vTaskSwitchContext+0xa0>)
 8000bd6:	2200      	movs	r2, #0
 8000bd8:	601a      	str	r2, [r3, #0]
				ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
 8000bda:	f000 fb31 	bl	8001240 <prf_timer_osmeasurer_count_get>
			if( ulTotalRunTime > ulTaskSwitchedInTime )
 8000bde:	4b22      	ldr	r3, [pc, #136]	; (8000c68 <vTaskSwitchContext+0xa4>)
 8000be0:	681b      	ldr	r3, [r3, #0]
 8000be2:	4298      	cmp	r0, r3
 8000be4:	d905      	bls.n	8000bf2 <vTaskSwitchContext+0x2e>
				pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
 8000be6:	4a21      	ldr	r2, [pc, #132]	; (8000c6c <vTaskSwitchContext+0xa8>)
 8000be8:	6811      	ldr	r1, [r2, #0]
 8000bea:	1ac3      	subs	r3, r0, r3
 8000bec:	6d4a      	ldr	r2, [r1, #84]	; 0x54
 8000bee:	4413      	add	r3, r2
 8000bf0:	654b      	str	r3, [r1, #84]	; 0x54
			ulTaskSwitchedInTime = ulTotalRunTime;
 8000bf2:	4b1d      	ldr	r3, [pc, #116]	; (8000c68 <vTaskSwitchContext+0xa4>)
 8000bf4:	6018      	str	r0, [r3, #0]
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8000bf6:	4b1e      	ldr	r3, [pc, #120]	; (8000c70 <vTaskSwitchContext+0xac>)
 8000bf8:	681b      	ldr	r3, [r3, #0]
		__asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) : "memory" );
 8000bfa:	fab3 f383 	clz	r3, r3
 8000bfe:	b2db      	uxtb	r3, r3
 8000c00:	f1c3 031f 	rsb	r3, r3, #31
 8000c04:	eb03 0183 	add.w	r1, r3, r3, lsl #2
 8000c08:	008a      	lsls	r2, r1, #2
 8000c0a:	491a      	ldr	r1, [pc, #104]	; (8000c74 <vTaskSwitchContext+0xb0>)
 8000c0c:	588a      	ldr	r2, [r1, r2]
 8000c0e:	b942      	cbnz	r2, 8000c22 <vTaskSwitchContext+0x5e>
	__asm volatile
 8000c10:	f04f 0350 	mov.w	r3, #80	; 0x50
 8000c14:	f383 8811 	msr	BASEPRI, r3
 8000c18:	f3bf 8f6f 	isb	sy
 8000c1c:	f3bf 8f4f 	dsb	sy
 8000c20:	e7fe      	b.n	8000c20 <vTaskSwitchContext+0x5c>
 8000c22:	4814      	ldr	r0, [pc, #80]	; (8000c74 <vTaskSwitchContext+0xb0>)
 8000c24:	009a      	lsls	r2, r3, #2
 8000c26:	18d4      	adds	r4, r2, r3
 8000c28:	00a1      	lsls	r1, r4, #2
 8000c2a:	4401      	add	r1, r0
 8000c2c:	684c      	ldr	r4, [r1, #4]
 8000c2e:	6864      	ldr	r4, [r4, #4]
 8000c30:	604c      	str	r4, [r1, #4]
 8000c32:	441a      	add	r2, r3
 8000c34:	0091      	lsls	r1, r2, #2
 8000c36:	3108      	adds	r1, #8
 8000c38:	4408      	add	r0, r1
 8000c3a:	4284      	cmp	r4, r0
 8000c3c:	d009      	beq.n	8000c52 <vTaskSwitchContext+0x8e>
 8000c3e:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8000c42:	009a      	lsls	r2, r3, #2
 8000c44:	4b0b      	ldr	r3, [pc, #44]	; (8000c74 <vTaskSwitchContext+0xb0>)
 8000c46:	4413      	add	r3, r2
 8000c48:	685b      	ldr	r3, [r3, #4]
 8000c4a:	68da      	ldr	r2, [r3, #12]
 8000c4c:	4b07      	ldr	r3, [pc, #28]	; (8000c6c <vTaskSwitchContext+0xa8>)
 8000c4e:	601a      	str	r2, [r3, #0]
}
 8000c50:	bd10      	pop	{r4, pc}
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8000c52:	6861      	ldr	r1, [r4, #4]
 8000c54:	4807      	ldr	r0, [pc, #28]	; (8000c74 <vTaskSwitchContext+0xb0>)
 8000c56:	2214      	movs	r2, #20
 8000c58:	fb02 0203 	mla	r2, r2, r3, r0
 8000c5c:	6051      	str	r1, [r2, #4]
 8000c5e:	e7ee      	b.n	8000c3e <vTaskSwitchContext+0x7a>
 8000c60:	20000538 	.word	0x20000538
 8000c64:	200005bc 	.word	0x200005bc
 8000c68:	20000528 	.word	0x20000528
 8000c6c:	20000490 	.word	0x20000490
 8000c70:	20000540 	.word	0x20000540
 8000c74:	2000049c 	.word	0x2000049c

08000c78 <prvTaskExitError>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

static void prvTaskExitError( void )
{
 8000c78:	b082      	sub	sp, #8
volatile uint32_t ulDummy = 0;
 8000c7a:	2300      	movs	r3, #0
 8000c7c:	9301      	str	r3, [sp, #4]
	its caller as there is nothing to return to.  If a task wants to exit it
	should instead call vTaskDelete( NULL ).

	Artificially force an assert() to be triggered if configASSERT() is
	defined, then stop here so application writers can catch the error. */
	configASSERT( uxCriticalNesting == ~0UL );
 8000c7e:	4b0d      	ldr	r3, [pc, #52]	; (8000cb4 <prvTaskExitError+0x3c>)
 8000c80:	681b      	ldr	r3, [r3, #0]
 8000c82:	f1b3 3fff 	cmp.w	r3, #4294967295
 8000c86:	d008      	beq.n	8000c9a <prvTaskExitError+0x22>
 8000c88:	f04f 0350 	mov.w	r3, #80	; 0x50
 8000c8c:	f383 8811 	msr	BASEPRI, r3
 8000c90:	f3bf 8f6f 	isb	sy
 8000c94:	f3bf 8f4f 	dsb	sy
 8000c98:	e7fe      	b.n	8000c98 <prvTaskExitError+0x20>
 8000c9a:	f04f 0350 	mov.w	r3, #80	; 0x50
 8000c9e:	f383 8811 	msr	BASEPRI, r3
 8000ca2:	f3bf 8f6f 	isb	sy
 8000ca6:	f3bf 8f4f 	dsb	sy
	portDISABLE_INTERRUPTS();
	while( ulDummy == 0 )
 8000caa:	9b01      	ldr	r3, [sp, #4]
 8000cac:	2b00      	cmp	r3, #0
 8000cae:	d0fc      	beq.n	8000caa <prvTaskExitError+0x32>
		about code appearing after this function is called - making ulDummy
		volatile makes the compiler think the function could return and
		therefore not output an 'unreachable code' warning for code that appears
		after it. */
	}
}
 8000cb0:	b002      	add	sp, #8
 8000cb2:	4770      	bx	lr
 8000cb4:	2000000c 	.word	0x2000000c

08000cb8 <prvPortStartFirstTask>:
{
	/* Start the first task.  This also clears the bit that indicates the FPU is
	in use in case the FPU was used before the scheduler was started - which
	would otherwise result in the unnecessary leaving of space in the SVC stack
	for lazy saving of FPU registers. */
	__asm volatile(
 8000cb8:	4808      	ldr	r0, [pc, #32]	; (8000cdc <prvPortStartFirstTask+0x24>)
 8000cba:	6800      	ldr	r0, [r0, #0]
 8000cbc:	6800      	ldr	r0, [r0, #0]
 8000cbe:	f380 8808 	msr	MSP, r0
 8000cc2:	f04f 0000 	mov.w	r0, #0
 8000cc6:	f380 8814 	msr	CONTROL, r0
 8000cca:	b662      	cpsie	i
 8000ccc:	b661      	cpsie	f
 8000cce:	f3bf 8f4f 	dsb	sy
 8000cd2:	f3bf 8f6f 	isb	sy
 8000cd6:	df00      	svc	0
 8000cd8:	bf00      	nop
 8000cda:	0000      	.short	0x0000
 8000cdc:	e000ed08 	.word	0xe000ed08

08000ce0 <vPortEnableVFP>:
/*-----------------------------------------------------------*/

/* This is a naked function. */
static void vPortEnableVFP( void )
{
	__asm volatile
 8000ce0:	f8df 000c 	ldr.w	r0, [pc, #12]	; 8000cf0 <vPortEnableVFP+0x10>
 8000ce4:	6801      	ldr	r1, [r0, #0]
 8000ce6:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 8000cea:	6001      	str	r1, [r0, #0]
 8000cec:	4770      	bx	lr
 8000cee:	0000      	.short	0x0000
 8000cf0:	e000ed88 	.word	0xe000ed88

08000cf4 <pxPortInitialiseStack>:
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
 8000cf4:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 8000cf8:	f840 3c04 	str.w	r3, [r0, #-4]
	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
 8000cfc:	f021 0101 	bic.w	r1, r1, #1
 8000d00:	f840 1c08 	str.w	r1, [r0, #-8]
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
 8000d04:	4b05      	ldr	r3, [pc, #20]	; (8000d1c <pxPortInitialiseStack+0x28>)
 8000d06:	f840 3c0c 	str.w	r3, [r0, #-12]
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
 8000d0a:	f840 2c20 	str.w	r2, [r0, #-32]
	*pxTopOfStack = portINITIAL_EXC_RETURN;
 8000d0e:	f06f 0302 	mvn.w	r3, #2
 8000d12:	f840 3c24 	str.w	r3, [r0, #-36]
}
 8000d16:	3844      	subs	r0, #68	; 0x44
 8000d18:	4770      	bx	lr
 8000d1a:	bf00      	nop
 8000d1c:	08000c79 	.word	0x08000c79

08000d20 <SVC_Handler>:
	__asm volatile (
 8000d20:	4b07      	ldr	r3, [pc, #28]	; (8000d40 <pxCurrentTCBConst2>)
 8000d22:	6819      	ldr	r1, [r3, #0]
 8000d24:	6808      	ldr	r0, [r1, #0]
 8000d26:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8000d2a:	f380 8809 	msr	PSP, r0
 8000d2e:	f3bf 8f6f 	isb	sy
 8000d32:	f04f 0000 	mov.w	r0, #0
 8000d36:	f380 8811 	msr	BASEPRI, r0
 8000d3a:	4770      	bx	lr
 8000d3c:	f3af 8000 	nop.w

08000d40 <pxCurrentTCBConst2>:
 8000d40:	20000490 	.word	0x20000490

08000d44 <vPortEnterCritical>:
 8000d44:	f04f 0350 	mov.w	r3, #80	; 0x50
 8000d48:	f383 8811 	msr	BASEPRI, r3
 8000d4c:	f3bf 8f6f 	isb	sy
 8000d50:	f3bf 8f4f 	dsb	sy
	uxCriticalNesting++;
 8000d54:	4a0a      	ldr	r2, [pc, #40]	; (8000d80 <vPortEnterCritical+0x3c>)
 8000d56:	6813      	ldr	r3, [r2, #0]
 8000d58:	3301      	adds	r3, #1
 8000d5a:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 1 )
 8000d5c:	2b01      	cmp	r3, #1
 8000d5e:	d000      	beq.n	8000d62 <vPortEnterCritical+0x1e>
}
 8000d60:	4770      	bx	lr
		configASSERT( ( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0 );
 8000d62:	4b08      	ldr	r3, [pc, #32]	; (8000d84 <vPortEnterCritical+0x40>)
 8000d64:	681b      	ldr	r3, [r3, #0]
 8000d66:	f013 0fff 	tst.w	r3, #255	; 0xff
 8000d6a:	d0f9      	beq.n	8000d60 <vPortEnterCritical+0x1c>
 8000d6c:	f04f 0350 	mov.w	r3, #80	; 0x50
 8000d70:	f383 8811 	msr	BASEPRI, r3
 8000d74:	f3bf 8f6f 	isb	sy
 8000d78:	f3bf 8f4f 	dsb	sy
 8000d7c:	e7fe      	b.n	8000d7c <vPortEnterCritical+0x38>
 8000d7e:	bf00      	nop
 8000d80:	2000000c 	.word	0x2000000c
 8000d84:	e000ed04 	.word	0xe000ed04

08000d88 <vPortExitCritical>:
	configASSERT( uxCriticalNesting );
 8000d88:	4b09      	ldr	r3, [pc, #36]	; (8000db0 <vPortExitCritical+0x28>)
 8000d8a:	681b      	ldr	r3, [r3, #0]
 8000d8c:	b943      	cbnz	r3, 8000da0 <vPortExitCritical+0x18>
 8000d8e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8000d92:	f383 8811 	msr	BASEPRI, r3
 8000d96:	f3bf 8f6f 	isb	sy
 8000d9a:	f3bf 8f4f 	dsb	sy
 8000d9e:	e7fe      	b.n	8000d9e <vPortExitCritical+0x16>
	uxCriticalNesting--;
 8000da0:	3b01      	subs	r3, #1
 8000da2:	4a03      	ldr	r2, [pc, #12]	; (8000db0 <vPortExitCritical+0x28>)
 8000da4:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 0 )
 8000da6:	b90b      	cbnz	r3, 8000dac <vPortExitCritical+0x24>
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
 8000da8:	f383 8811 	msr	BASEPRI, r3
}
 8000dac:	4770      	bx	lr
 8000dae:	bf00      	nop
 8000db0:	2000000c 	.word	0x2000000c
	...

08000dc0 <PendSV_Handler>:
	__asm volatile
 8000dc0:	f3ef 8009 	mrs	r0, PSP
 8000dc4:	f3bf 8f6f 	isb	sy
 8000dc8:	4b15      	ldr	r3, [pc, #84]	; (8000e20 <pxCurrentTCBConst>)
 8000dca:	681a      	ldr	r2, [r3, #0]
 8000dcc:	f01e 0f10 	tst.w	lr, #16
 8000dd0:	bf08      	it	eq
 8000dd2:	ed20 8a10 	vstmdbeq	r0!, {s16-s31}
 8000dd6:	e920 4ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8000dda:	6010      	str	r0, [r2, #0]
 8000ddc:	e92d 0009 	stmdb	sp!, {r0, r3}
 8000de0:	f04f 0050 	mov.w	r0, #80	; 0x50
 8000de4:	f380 8811 	msr	BASEPRI, r0
 8000de8:	f3bf 8f4f 	dsb	sy
 8000dec:	f3bf 8f6f 	isb	sy
 8000df0:	f7ff fee8 	bl	8000bc4 <vTaskSwitchContext>
 8000df4:	f04f 0000 	mov.w	r0, #0
 8000df8:	f380 8811 	msr	BASEPRI, r0
 8000dfc:	bc09      	pop	{r0, r3}
 8000dfe:	6819      	ldr	r1, [r3, #0]
 8000e00:	6808      	ldr	r0, [r1, #0]
 8000e02:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8000e06:	f01e 0f10 	tst.w	lr, #16
 8000e0a:	bf08      	it	eq
 8000e0c:	ecb0 8a10 	vldmiaeq	r0!, {s16-s31}
 8000e10:	f380 8809 	msr	PSP, r0
 8000e14:	f3bf 8f6f 	isb	sy
 8000e18:	4770      	bx	lr
 8000e1a:	bf00      	nop
 8000e1c:	f3af 8000 	nop.w

08000e20 <pxCurrentTCBConst>:
 8000e20:	20000490 	.word	0x20000490

08000e24 <SysTick_Handler>:
{
 8000e24:	b508      	push	{r3, lr}
	__asm volatile
 8000e26:	f04f 0350 	mov.w	r3, #80	; 0x50
 8000e2a:	f383 8811 	msr	BASEPRI, r3
 8000e2e:	f3bf 8f6f 	isb	sy
 8000e32:	f3bf 8f4f 	dsb	sy
		if( xTaskIncrementTick() != pdFALSE )
 8000e36:	f7ff fd99 	bl	800096c <xTaskIncrementTick>
 8000e3a:	b118      	cbz	r0, 8000e44 <SysTick_Handler+0x20>
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
 8000e3c:	4b03      	ldr	r3, [pc, #12]	; (8000e4c <SysTick_Handler+0x28>)
 8000e3e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8000e42:	601a      	str	r2, [r3, #0]
	__asm volatile
 8000e44:	2300      	movs	r3, #0
 8000e46:	f383 8811 	msr	BASEPRI, r3
}
 8000e4a:	bd08      	pop	{r3, pc}
 8000e4c:	e000ed04 	.word	0xe000ed04

08000e50 <vPortSetupTimerInterrupt>:
	portNVIC_SYSTICK_CTRL_REG = 0UL;
 8000e50:	4a08      	ldr	r2, [pc, #32]	; (8000e74 <vPortSetupTimerInterrupt+0x24>)
 8000e52:	2300      	movs	r3, #0
 8000e54:	6013      	str	r3, [r2, #0]
	portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
 8000e56:	4908      	ldr	r1, [pc, #32]	; (8000e78 <vPortSetupTimerInterrupt+0x28>)
 8000e58:	600b      	str	r3, [r1, #0]
	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 8000e5a:	4b08      	ldr	r3, [pc, #32]	; (8000e7c <vPortSetupTimerInterrupt+0x2c>)
 8000e5c:	681b      	ldr	r3, [r3, #0]
 8000e5e:	4908      	ldr	r1, [pc, #32]	; (8000e80 <vPortSetupTimerInterrupt+0x30>)
 8000e60:	fba1 1303 	umull	r1, r3, r1, r3
 8000e64:	099b      	lsrs	r3, r3, #6
 8000e66:	3b01      	subs	r3, #1
 8000e68:	4906      	ldr	r1, [pc, #24]	; (8000e84 <vPortSetupTimerInterrupt+0x34>)
 8000e6a:	600b      	str	r3, [r1, #0]
	portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
 8000e6c:	2307      	movs	r3, #7
 8000e6e:	6013      	str	r3, [r2, #0]
}
 8000e70:	4770      	bx	lr
 8000e72:	bf00      	nop
 8000e74:	e000e010 	.word	0xe000e010
 8000e78:	e000e018 	.word	0xe000e018
 8000e7c:	20000000 	.word	0x20000000
 8000e80:	10624dd3 	.word	0x10624dd3
 8000e84:	e000e014 	.word	0xe000e014

08000e88 <xPortStartScheduler>:
	configASSERT( portCPUID != portCORTEX_M7_r0p1_ID );
 8000e88:	4b3a      	ldr	r3, [pc, #232]	; (8000f74 <xPortStartScheduler+0xec>)
 8000e8a:	681a      	ldr	r2, [r3, #0]
 8000e8c:	4b3a      	ldr	r3, [pc, #232]	; (8000f78 <xPortStartScheduler+0xf0>)
 8000e8e:	429a      	cmp	r2, r3
 8000e90:	d00d      	beq.n	8000eae <xPortStartScheduler+0x26>
	configASSERT( portCPUID != portCORTEX_M7_r0p0_ID );
 8000e92:	4b38      	ldr	r3, [pc, #224]	; (8000f74 <xPortStartScheduler+0xec>)
 8000e94:	681a      	ldr	r2, [r3, #0]
 8000e96:	4b39      	ldr	r3, [pc, #228]	; (8000f7c <xPortStartScheduler+0xf4>)
 8000e98:	429a      	cmp	r2, r3
 8000e9a:	d111      	bne.n	8000ec0 <xPortStartScheduler+0x38>
	__asm volatile
 8000e9c:	f04f 0350 	mov.w	r3, #80	; 0x50
 8000ea0:	f383 8811 	msr	BASEPRI, r3
 8000ea4:	f3bf 8f6f 	isb	sy
 8000ea8:	f3bf 8f4f 	dsb	sy
 8000eac:	e7fe      	b.n	8000eac <xPortStartScheduler+0x24>
 8000eae:	f04f 0350 	mov.w	r3, #80	; 0x50
 8000eb2:	f383 8811 	msr	BASEPRI, r3
 8000eb6:	f3bf 8f6f 	isb	sy
 8000eba:	f3bf 8f4f 	dsb	sy
 8000ebe:	e7fe      	b.n	8000ebe <xPortStartScheduler+0x36>
{
 8000ec0:	b510      	push	{r4, lr}
 8000ec2:	b082      	sub	sp, #8
		ulOriginalPriority = *pucFirstUserPriorityRegister;
 8000ec4:	4b2e      	ldr	r3, [pc, #184]	; (8000f80 <xPortStartScheduler+0xf8>)
 8000ec6:	781a      	ldrb	r2, [r3, #0]
 8000ec8:	b2d2      	uxtb	r2, r2
 8000eca:	9201      	str	r2, [sp, #4]
		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
 8000ecc:	22ff      	movs	r2, #255	; 0xff
 8000ece:	701a      	strb	r2, [r3, #0]
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
 8000ed0:	781b      	ldrb	r3, [r3, #0]
 8000ed2:	b2db      	uxtb	r3, r3
 8000ed4:	f88d 3003 	strb.w	r3, [sp, #3]
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 8000ed8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8000edc:	f003 0350 	and.w	r3, r3, #80	; 0x50
 8000ee0:	4a28      	ldr	r2, [pc, #160]	; (8000f84 <xPortStartScheduler+0xfc>)
 8000ee2:	7013      	strb	r3, [r2, #0]
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
 8000ee4:	4b28      	ldr	r3, [pc, #160]	; (8000f88 <xPortStartScheduler+0x100>)
 8000ee6:	2207      	movs	r2, #7
 8000ee8:	601a      	str	r2, [r3, #0]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 8000eea:	e009      	b.n	8000f00 <xPortStartScheduler+0x78>
			ulMaxPRIGROUPValue--;
 8000eec:	4a26      	ldr	r2, [pc, #152]	; (8000f88 <xPortStartScheduler+0x100>)
 8000eee:	6813      	ldr	r3, [r2, #0]
 8000ef0:	3b01      	subs	r3, #1
 8000ef2:	6013      	str	r3, [r2, #0]
			ucMaxPriorityValue <<= ( uint8_t ) 0x01;
 8000ef4:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8000ef8:	005b      	lsls	r3, r3, #1
 8000efa:	b2db      	uxtb	r3, r3
 8000efc:	f88d 3003 	strb.w	r3, [sp, #3]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 8000f00:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8000f04:	f013 0f80 	tst.w	r3, #128	; 0x80
 8000f08:	d1f0      	bne.n	8000eec <xPortStartScheduler+0x64>
			configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == __NVIC_PRIO_BITS );
 8000f0a:	4b1f      	ldr	r3, [pc, #124]	; (8000f88 <xPortStartScheduler+0x100>)
 8000f0c:	681b      	ldr	r3, [r3, #0]
 8000f0e:	2b03      	cmp	r3, #3
 8000f10:	d008      	beq.n	8000f24 <xPortStartScheduler+0x9c>
 8000f12:	f04f 0350 	mov.w	r3, #80	; 0x50
 8000f16:	f383 8811 	msr	BASEPRI, r3
 8000f1a:	f3bf 8f6f 	isb	sy
 8000f1e:	f3bf 8f4f 	dsb	sy
 8000f22:	e7fe      	b.n	8000f22 <xPortStartScheduler+0x9a>
		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
 8000f24:	021b      	lsls	r3, r3, #8
		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
 8000f26:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 8000f2a:	4a17      	ldr	r2, [pc, #92]	; (8000f88 <xPortStartScheduler+0x100>)
 8000f2c:	6013      	str	r3, [r2, #0]
		*pucFirstUserPriorityRegister = ulOriginalPriority;
 8000f2e:	9b01      	ldr	r3, [sp, #4]
 8000f30:	b2db      	uxtb	r3, r3
 8000f32:	4a13      	ldr	r2, [pc, #76]	; (8000f80 <xPortStartScheduler+0xf8>)
 8000f34:	7013      	strb	r3, [r2, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
 8000f36:	4b15      	ldr	r3, [pc, #84]	; (8000f8c <xPortStartScheduler+0x104>)
 8000f38:	681a      	ldr	r2, [r3, #0]
 8000f3a:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
 8000f3e:	601a      	str	r2, [r3, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
 8000f40:	681a      	ldr	r2, [r3, #0]
 8000f42:	f042 4270 	orr.w	r2, r2, #4026531840	; 0xf0000000
 8000f46:	601a      	str	r2, [r3, #0]
	vPortSetupTimerInterrupt();
 8000f48:	f7ff ff82 	bl	8000e50 <vPortSetupTimerInterrupt>
	uxCriticalNesting = 0;
 8000f4c:	2400      	movs	r4, #0
 8000f4e:	4b10      	ldr	r3, [pc, #64]	; (8000f90 <xPortStartScheduler+0x108>)
 8000f50:	601c      	str	r4, [r3, #0]
	vPortEnableVFP();
 8000f52:	f7ff fec5 	bl	8000ce0 <vPortEnableVFP>
	*( portFPCCR ) |= portASPEN_AND_LSPEN_BITS;
 8000f56:	4a0f      	ldr	r2, [pc, #60]	; (8000f94 <xPortStartScheduler+0x10c>)
 8000f58:	6813      	ldr	r3, [r2, #0]
 8000f5a:	f043 4340 	orr.w	r3, r3, #3221225472	; 0xc0000000
 8000f5e:	6013      	str	r3, [r2, #0]
	prvPortStartFirstTask();
 8000f60:	f7ff feaa 	bl	8000cb8 <prvPortStartFirstTask>
	vTaskSwitchContext();
 8000f64:	f7ff fe2e 	bl	8000bc4 <vTaskSwitchContext>
	prvTaskExitError();
 8000f68:	f7ff fe86 	bl	8000c78 <prvTaskExitError>
}
 8000f6c:	4620      	mov	r0, r4
 8000f6e:	b002      	add	sp, #8
 8000f70:	bd10      	pop	{r4, pc}
 8000f72:	bf00      	nop
 8000f74:	e000ed00 	.word	0xe000ed00
 8000f78:	410fc271 	.word	0x410fc271
 8000f7c:	410fc270 	.word	0x410fc270
 8000f80:	e000e400 	.word	0xe000e400
 8000f84:	200005c0 	.word	0x200005c0
 8000f88:	200005c4 	.word	0x200005c4
 8000f8c:	e000ed20 	.word	0xe000ed20
 8000f90:	2000000c 	.word	0x2000000c
 8000f94:	e000ef34 	.word	0xe000ef34

08000f98 <prvHeapInit>:
uint8_t *pucAlignedHeap;
size_t uxAddress;
size_t xTotalHeapSize = configTOTAL_HEAP_SIZE;

	/* Ensure the heap starts on a correctly aligned boundary. */
	uxAddress = ( size_t ) ucHeap;
 8000f98:	4a12      	ldr	r2, [pc, #72]	; (8000fe4 <prvHeapInit+0x4c>)

	if( ( uxAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
 8000f9a:	f012 0f07 	tst.w	r2, #7
 8000f9e:	d01e      	beq.n	8000fde <prvHeapInit+0x46>
	{
		uxAddress += ( portBYTE_ALIGNMENT - 1 );
 8000fa0:	1dd1      	adds	r1, r2, #7
		uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 8000fa2:	f021 0107 	bic.w	r1, r1, #7
		xTotalHeapSize -= uxAddress - ( size_t ) ucHeap;
 8000fa6:	f5c1 5370 	rsb	r3, r1, #15360	; 0x3c00
 8000faa:	4413      	add	r3, r2
		uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 8000fac:	460a      	mov	r2, r1

	pucAlignedHeap = ( uint8_t * ) uxAddress;

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
 8000fae:	480e      	ldr	r0, [pc, #56]	; (8000fe8 <prvHeapInit+0x50>)
 8000fb0:	6002      	str	r2, [r0, #0]
	xStart.xBlockSize = ( size_t ) 0;
 8000fb2:	2100      	movs	r1, #0
 8000fb4:	6041      	str	r1, [r0, #4]

	/* pxEnd is used to mark the end of the list of free blocks and is inserted
	at the end of the heap space. */
	uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
 8000fb6:	4413      	add	r3, r2
	uxAddress -= xHeapStructSize;
 8000fb8:	3b08      	subs	r3, #8
	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 8000fba:	f023 0307 	bic.w	r3, r3, #7
	pxEnd = ( void * ) uxAddress;
 8000fbe:	480b      	ldr	r0, [pc, #44]	; (8000fec <prvHeapInit+0x54>)
 8000fc0:	6003      	str	r3, [r0, #0]
	pxEnd->xBlockSize = 0;
 8000fc2:	6059      	str	r1, [r3, #4]
	pxEnd->pxNextFreeBlock = NULL;
 8000fc4:	6019      	str	r1, [r3, #0]

	/* To start with there is a single free block that is sized to take up the
	entire heap space, minus the space taken by pxEnd. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
 8000fc6:	1a99      	subs	r1, r3, r2
 8000fc8:	6051      	str	r1, [r2, #4]
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
 8000fca:	6013      	str	r3, [r2, #0]

	/* Only one block exists - and it covers the entire usable heap space. */
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 8000fcc:	4b08      	ldr	r3, [pc, #32]	; (8000ff0 <prvHeapInit+0x58>)
 8000fce:	6019      	str	r1, [r3, #0]
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 8000fd0:	4b08      	ldr	r3, [pc, #32]	; (8000ff4 <prvHeapInit+0x5c>)
 8000fd2:	6019      	str	r1, [r3, #0]

	/* Work out the position of the top bit in a size_t variable. */
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
 8000fd4:	4b08      	ldr	r3, [pc, #32]	; (8000ff8 <prvHeapInit+0x60>)
 8000fd6:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
 8000fda:	601a      	str	r2, [r3, #0]
}
 8000fdc:	4770      	bx	lr
size_t xTotalHeapSize = configTOTAL_HEAP_SIZE;
 8000fde:	f44f 5370 	mov.w	r3, #15360	; 0x3c00
 8000fe2:	e7e4      	b.n	8000fae <prvHeapInit+0x16>
 8000fe4:	200005cc 	.word	0x200005cc
 8000fe8:	200041d8 	.word	0x200041d8
 8000fec:	200005c8 	.word	0x200005c8
 8000ff0:	200041d4 	.word	0x200041d4
 8000ff4:	200041d0 	.word	0x200041d0
 8000ff8:	200041cc 	.word	0x200041cc

08000ffc <prvInsertBlockIntoFreeList>:
/*-----------------------------------------------------------*/

static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )
{
 8000ffc:	b410      	push	{r4}
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
 8000ffe:	4b13      	ldr	r3, [pc, #76]	; (800104c <prvInsertBlockIntoFreeList+0x50>)
 8001000:	681a      	ldr	r2, [r3, #0]
 8001002:	4282      	cmp	r2, r0
 8001004:	d31b      	bcc.n	800103e <prvInsertBlockIntoFreeList+0x42>
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
 8001006:	6859      	ldr	r1, [r3, #4]
 8001008:	185c      	adds	r4, r3, r1
 800100a:	4284      	cmp	r4, r0
 800100c:	d103      	bne.n	8001016 <prvInsertBlockIntoFreeList+0x1a>
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
 800100e:	6840      	ldr	r0, [r0, #4]
 8001010:	4401      	add	r1, r0
 8001012:	6059      	str	r1, [r3, #4]
		pxBlockToInsert = pxIterator;
 8001014:	4618      	mov	r0, r3
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
 8001016:	6841      	ldr	r1, [r0, #4]
 8001018:	1844      	adds	r4, r0, r1
 800101a:	42a2      	cmp	r2, r4
 800101c:	d113      	bne.n	8001046 <prvInsertBlockIntoFreeList+0x4a>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
 800101e:	4c0c      	ldr	r4, [pc, #48]	; (8001050 <prvInsertBlockIntoFreeList+0x54>)
 8001020:	6824      	ldr	r4, [r4, #0]
 8001022:	42a2      	cmp	r2, r4
 8001024:	d00d      	beq.n	8001042 <prvInsertBlockIntoFreeList+0x46>
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 8001026:	6852      	ldr	r2, [r2, #4]
 8001028:	4411      	add	r1, r2
 800102a:	6041      	str	r1, [r0, #4]
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
 800102c:	681a      	ldr	r2, [r3, #0]
 800102e:	6812      	ldr	r2, [r2, #0]
 8001030:	6002      	str	r2, [r0, #0]

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
 8001032:	4298      	cmp	r0, r3
 8001034:	d000      	beq.n	8001038 <prvInsertBlockIntoFreeList+0x3c>
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
 8001036:	6018      	str	r0, [r3, #0]
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
 8001038:	f85d 4b04 	ldr.w	r4, [sp], #4
 800103c:	4770      	bx	lr
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
 800103e:	4613      	mov	r3, r2
 8001040:	e7de      	b.n	8001000 <prvInsertBlockIntoFreeList+0x4>
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
 8001042:	6004      	str	r4, [r0, #0]
 8001044:	e7f5      	b.n	8001032 <prvInsertBlockIntoFreeList+0x36>
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
 8001046:	6002      	str	r2, [r0, #0]
 8001048:	e7f3      	b.n	8001032 <prvInsertBlockIntoFreeList+0x36>
 800104a:	bf00      	nop
 800104c:	200041d8 	.word	0x200041d8
 8001050:	200005c8 	.word	0x200005c8

08001054 <pvPortMalloc>:
{
 8001054:	b570      	push	{r4, r5, r6, lr}
 8001056:	4604      	mov	r4, r0
	vTaskSuspendAll();
 8001058:	f7ff fc80 	bl	800095c <vTaskSuspendAll>
		if( pxEnd == NULL )
 800105c:	4b3a      	ldr	r3, [pc, #232]	; (8001148 <pvPortMalloc+0xf4>)
 800105e:	681b      	ldr	r3, [r3, #0]
 8001060:	b1bb      	cbz	r3, 8001092 <pvPortMalloc+0x3e>
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
 8001062:	4b3a      	ldr	r3, [pc, #232]	; (800114c <pvPortMalloc+0xf8>)
 8001064:	681b      	ldr	r3, [r3, #0]
 8001066:	421c      	tst	r4, r3
 8001068:	d163      	bne.n	8001132 <pvPortMalloc+0xde>
			if( xWantedSize > 0 )
 800106a:	b1ac      	cbz	r4, 8001098 <pvPortMalloc+0x44>
				xWantedSize += xHeapStructSize;
 800106c:	3408      	adds	r4, #8
				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
 800106e:	f014 0f07 	tst.w	r4, #7
 8001072:	d011      	beq.n	8001098 <pvPortMalloc+0x44>
					xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
 8001074:	f024 0407 	bic.w	r4, r4, #7
 8001078:	3408      	adds	r4, #8
					configASSERT( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) == 0 );
 800107a:	f004 0307 	and.w	r3, r4, #7
 800107e:	b15b      	cbz	r3, 8001098 <pvPortMalloc+0x44>
 8001080:	f04f 0350 	mov.w	r3, #80	; 0x50
 8001084:	f383 8811 	msr	BASEPRI, r3
 8001088:	f3bf 8f6f 	isb	sy
 800108c:	f3bf 8f4f 	dsb	sy
 8001090:	e7fe      	b.n	8001090 <pvPortMalloc+0x3c>
			prvHeapInit();
 8001092:	f7ff ff81 	bl	8000f98 <prvHeapInit>
 8001096:	e7e4      	b.n	8001062 <pvPortMalloc+0xe>
			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
 8001098:	2c00      	cmp	r4, #0
 800109a:	d04c      	beq.n	8001136 <pvPortMalloc+0xe2>
 800109c:	4b2c      	ldr	r3, [pc, #176]	; (8001150 <pvPortMalloc+0xfc>)
 800109e:	681b      	ldr	r3, [r3, #0]
 80010a0:	42a3      	cmp	r3, r4
 80010a2:	d34a      	bcc.n	800113a <pvPortMalloc+0xe6>
				pxBlock = xStart.pxNextFreeBlock;
 80010a4:	4b2b      	ldr	r3, [pc, #172]	; (8001154 <pvPortMalloc+0x100>)
 80010a6:	681d      	ldr	r5, [r3, #0]
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 80010a8:	e001      	b.n	80010ae <pvPortMalloc+0x5a>
					pxPreviousBlock = pxBlock;
 80010aa:	462b      	mov	r3, r5
					pxBlock = pxBlock->pxNextFreeBlock;
 80010ac:	4615      	mov	r5, r2
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 80010ae:	686a      	ldr	r2, [r5, #4]
 80010b0:	42a2      	cmp	r2, r4
 80010b2:	d202      	bcs.n	80010ba <pvPortMalloc+0x66>
 80010b4:	682a      	ldr	r2, [r5, #0]
 80010b6:	2a00      	cmp	r2, #0
 80010b8:	d1f7      	bne.n	80010aa <pvPortMalloc+0x56>
				if( pxBlock != pxEnd )
 80010ba:	4a23      	ldr	r2, [pc, #140]	; (8001148 <pvPortMalloc+0xf4>)
 80010bc:	6812      	ldr	r2, [r2, #0]
 80010be:	42aa      	cmp	r2, r5
 80010c0:	d03d      	beq.n	800113e <pvPortMalloc+0xea>
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
 80010c2:	681e      	ldr	r6, [r3, #0]
 80010c4:	3608      	adds	r6, #8
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 80010c6:	682a      	ldr	r2, [r5, #0]
 80010c8:	601a      	str	r2, [r3, #0]
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 80010ca:	686b      	ldr	r3, [r5, #4]
 80010cc:	1b1b      	subs	r3, r3, r4
 80010ce:	2b10      	cmp	r3, #16
 80010d0:	d910      	bls.n	80010f4 <pvPortMalloc+0xa0>
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
 80010d2:	1928      	adds	r0, r5, r4
						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );
 80010d4:	f010 0f07 	tst.w	r0, #7
 80010d8:	d008      	beq.n	80010ec <pvPortMalloc+0x98>
 80010da:	f04f 0350 	mov.w	r3, #80	; 0x50
 80010de:	f383 8811 	msr	BASEPRI, r3
 80010e2:	f3bf 8f6f 	isb	sy
 80010e6:	f3bf 8f4f 	dsb	sy
 80010ea:	e7fe      	b.n	80010ea <pvPortMalloc+0x96>
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
 80010ec:	6043      	str	r3, [r0, #4]
						pxBlock->xBlockSize = xWantedSize;
 80010ee:	606c      	str	r4, [r5, #4]
						prvInsertBlockIntoFreeList( pxNewBlockLink );
 80010f0:	f7ff ff84 	bl	8000ffc <prvInsertBlockIntoFreeList>
					xFreeBytesRemaining -= pxBlock->xBlockSize;
 80010f4:	686a      	ldr	r2, [r5, #4]
 80010f6:	4916      	ldr	r1, [pc, #88]	; (8001150 <pvPortMalloc+0xfc>)
 80010f8:	680b      	ldr	r3, [r1, #0]
 80010fa:	1a9b      	subs	r3, r3, r2
 80010fc:	600b      	str	r3, [r1, #0]
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 80010fe:	4916      	ldr	r1, [pc, #88]	; (8001158 <pvPortMalloc+0x104>)
 8001100:	6809      	ldr	r1, [r1, #0]
 8001102:	428b      	cmp	r3, r1
 8001104:	d201      	bcs.n	800110a <pvPortMalloc+0xb6>
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
 8001106:	4914      	ldr	r1, [pc, #80]	; (8001158 <pvPortMalloc+0x104>)
 8001108:	600b      	str	r3, [r1, #0]
					pxBlock->xBlockSize |= xBlockAllocatedBit;
 800110a:	4b10      	ldr	r3, [pc, #64]	; (800114c <pvPortMalloc+0xf8>)
 800110c:	681b      	ldr	r3, [r3, #0]
 800110e:	4313      	orrs	r3, r2
 8001110:	606b      	str	r3, [r5, #4]
					pxBlock->pxNextFreeBlock = NULL;
 8001112:	2300      	movs	r3, #0
 8001114:	602b      	str	r3, [r5, #0]
	( void ) xTaskResumeAll();
 8001116:	f7ff fcb5 	bl	8000a84 <xTaskResumeAll>
	configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
 800111a:	f016 0f07 	tst.w	r6, #7
 800111e:	d010      	beq.n	8001142 <pvPortMalloc+0xee>
 8001120:	f04f 0350 	mov.w	r3, #80	; 0x50
 8001124:	f383 8811 	msr	BASEPRI, r3
 8001128:	f3bf 8f6f 	isb	sy
 800112c:	f3bf 8f4f 	dsb	sy
 8001130:	e7fe      	b.n	8001130 <pvPortMalloc+0xdc>
void *pvReturn = NULL;
 8001132:	2600      	movs	r6, #0
 8001134:	e7ef      	b.n	8001116 <pvPortMalloc+0xc2>
 8001136:	2600      	movs	r6, #0
 8001138:	e7ed      	b.n	8001116 <pvPortMalloc+0xc2>
 800113a:	2600      	movs	r6, #0
 800113c:	e7eb      	b.n	8001116 <pvPortMalloc+0xc2>
 800113e:	2600      	movs	r6, #0
 8001140:	e7e9      	b.n	8001116 <pvPortMalloc+0xc2>
}
 8001142:	4630      	mov	r0, r6
 8001144:	bd70      	pop	{r4, r5, r6, pc}
 8001146:	bf00      	nop
 8001148:	200005c8 	.word	0x200005c8
 800114c:	200041cc 	.word	0x200041cc
 8001150:	200041d0 	.word	0x200041d0
 8001154:	200041d8 	.word	0x200041d8
 8001158:	200041d4 	.word	0x200041d4

0800115c <vPortFree>:
	if( pv != NULL )
 800115c:	b380      	cbz	r0, 80011c0 <vPortFree+0x64>
{
 800115e:	b538      	push	{r3, r4, r5, lr}
 8001160:	4604      	mov	r4, r0
		puc -= xHeapStructSize;
 8001162:	f1a0 0508 	sub.w	r5, r0, #8
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
 8001166:	f850 2c04 	ldr.w	r2, [r0, #-4]
 800116a:	4916      	ldr	r1, [pc, #88]	; (80011c4 <vPortFree+0x68>)
 800116c:	6809      	ldr	r1, [r1, #0]
 800116e:	420a      	tst	r2, r1
 8001170:	d108      	bne.n	8001184 <vPortFree+0x28>
 8001172:	f04f 0350 	mov.w	r3, #80	; 0x50
 8001176:	f383 8811 	msr	BASEPRI, r3
 800117a:	f3bf 8f6f 	isb	sy
 800117e:	f3bf 8f4f 	dsb	sy
 8001182:	e7fe      	b.n	8001182 <vPortFree+0x26>
		configASSERT( pxLink->pxNextFreeBlock == NULL );
 8001184:	f850 0c08 	ldr.w	r0, [r0, #-8]
 8001188:	b140      	cbz	r0, 800119c <vPortFree+0x40>
 800118a:	f04f 0350 	mov.w	r3, #80	; 0x50
 800118e:	f383 8811 	msr	BASEPRI, r3
 8001192:	f3bf 8f6f 	isb	sy
 8001196:	f3bf 8f4f 	dsb	sy
 800119a:	e7fe      	b.n	800119a <vPortFree+0x3e>
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
 800119c:	ea22 0201 	bic.w	r2, r2, r1
 80011a0:	f844 2c04 	str.w	r2, [r4, #-4]
				vTaskSuspendAll();
 80011a4:	f7ff fbda 	bl	800095c <vTaskSuspendAll>
					xFreeBytesRemaining += pxLink->xBlockSize;
 80011a8:	f854 1c04 	ldr.w	r1, [r4, #-4]
 80011ac:	4a06      	ldr	r2, [pc, #24]	; (80011c8 <vPortFree+0x6c>)
 80011ae:	6813      	ldr	r3, [r2, #0]
 80011b0:	440b      	add	r3, r1
 80011b2:	6013      	str	r3, [r2, #0]
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
 80011b4:	4628      	mov	r0, r5
 80011b6:	f7ff ff21 	bl	8000ffc <prvInsertBlockIntoFreeList>
				( void ) xTaskResumeAll();
 80011ba:	f7ff fc63 	bl	8000a84 <xTaskResumeAll>
}
 80011be:	bd38      	pop	{r3, r4, r5, pc}
 80011c0:	4770      	bx	lr
 80011c2:	bf00      	nop
 80011c4:	200041cc 	.word	0x200041cc
 80011c8:	200041d0 	.word	0x200041d0

080011cc <_timer6_16_bit_init>:
	HAL_TIM_Base_Init(&htim5);
	HAL_TIM_Base_Start(&htim5);
}

static void _timer6_16_bit_init(uint32_t freq)
{
 80011cc:	b510      	push	{r4, lr}
 80011ce:	b082      	sub	sp, #8
	uint32_t prescaler_value = (uint32_t)((SystemCoreClock/4)/ freq) - 1;
 80011d0:	4b11      	ldr	r3, [pc, #68]	; (8001218 <_timer6_16_bit_init+0x4c>)
 80011d2:	681b      	ldr	r3, [r3, #0]
 80011d4:	089b      	lsrs	r3, r3, #2
 80011d6:	fbb3 f3f0 	udiv	r3, r3, r0
 80011da:	3b01      	subs	r3, #1
	htim6.Instance = OSTASKMEASURER_TIMER;
 80011dc:	4c0f      	ldr	r4, [pc, #60]	; (800121c <_timer6_16_bit_init+0x50>)
 80011de:	4a10      	ldr	r2, [pc, #64]	; (8001220 <_timer6_16_bit_init+0x54>)
 80011e0:	6022      	str	r2, [r4, #0]
	htim6.Init.Prescaler = prescaler_value;
 80011e2:	6063      	str	r3, [r4, #4]
	htim6.Init.Period = freq-1;
 80011e4:	3801      	subs	r0, #1
 80011e6:	60e0      	str	r0, [r4, #12]
	htim6.Init.ClockDivision = TIM_CLOCKDIVISION_DIV2;
 80011e8:	f44f 7380 	mov.w	r3, #256	; 0x100
 80011ec:	6123      	str	r3, [r4, #16]
	htim6.Init.CounterMode = TIM_COUNTERMODE_UP;
 80011ee:	2300      	movs	r3, #0
 80011f0:	60a3      	str	r3, [r4, #8]
	__HAL_RCC_TIM6_CLK_ENABLE();
 80011f2:	9301      	str	r3, [sp, #4]
 80011f4:	4b0b      	ldr	r3, [pc, #44]	; (8001224 <_timer6_16_bit_init+0x58>)
 80011f6:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80011f8:	f042 0210 	orr.w	r2, r2, #16
 80011fc:	641a      	str	r2, [r3, #64]	; 0x40
 80011fe:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8001200:	f003 0310 	and.w	r3, r3, #16
 8001204:	9301      	str	r3, [sp, #4]
 8001206:	9b01      	ldr	r3, [sp, #4]
	HAL_TIM_Base_Init(&htim6);
 8001208:	4620      	mov	r0, r4
 800120a:	f7ff f955 	bl	80004b8 <HAL_TIM_Base_Init>
	HAL_TIM_Base_Start(&htim6);
 800120e:	4620      	mov	r0, r4
 8001210:	f7ff f8db 	bl	80003ca <HAL_TIM_Base_Start>
}
 8001214:	b002      	add	sp, #8
 8001216:	bd10      	pop	{r4, pc}
 8001218:	20000000 	.word	0x20000000
 800121c:	200041e0 	.word	0x200041e0
 8001220:	40001000 	.word	0x40001000
 8001224:	40023800 	.word	0x40023800

08001228 <prf_timer_osmeasurer_init>:
{
 8001228:	b508      	push	{r3, lr}
	_timer6_16_bit_init(PERF_OSTASKMEASURER_FREQ);
 800122a:	f242 7010 	movw	r0, #10000	; 0x2710
 800122e:	f7ff ffcd 	bl	80011cc <_timer6_16_bit_init>
	htim5.Instance->CNT = 0;
}

static inline void _timer6_cnt_reset()
{
	htim6.Instance->CNT = 0;
 8001232:	4b02      	ldr	r3, [pc, #8]	; (800123c <prf_timer_osmeasurer_init+0x14>)
 8001234:	681b      	ldr	r3, [r3, #0]
 8001236:	2200      	movs	r2, #0
 8001238:	625a      	str	r2, [r3, #36]	; 0x24
}
 800123a:	bd08      	pop	{r3, pc}
 800123c:	200041e0 	.word	0x200041e0

08001240 <prf_timer_osmeasurer_count_get>:
	return htim6.Instance->CNT;
 8001240:	4b01      	ldr	r3, [pc, #4]	; (8001248 <prf_timer_osmeasurer_count_get+0x8>)
 8001242:	681b      	ldr	r3, [r3, #0]
 8001244:	6a58      	ldr	r0, [r3, #36]	; 0x24
}
 8001246:	4770      	bx	lr
 8001248:	200041e0 	.word	0x200041e0

0800124c <_startup_tasks_create>:
		{.result = 0, .thread = thread_init, .name = "Init", .stack_depth = configMINIMAL_STACK_SIZE, .parameters = NULL, .priority = 1},
		{.result = 0, .thread = thread_test, .name = "Test", .stack_depth = configMINIMAL_STACK_SIZE, .parameters = NULL, .priority = 1},
};


static void _startup_tasks_create() {
 800124c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8001250:	b083      	sub	sp, #12
	for(int i = 0; i < COUNT(startup_tasks); i++)
 8001252:	2400      	movs	r4, #0
 8001254:	e016      	b.n	8001284 <_startup_tasks_create+0x38>
	{
		startup_tasks[i].result =
		xTaskCreate(
		startup_tasks[i].thread,
		startup_tasks[i].name,
 8001256:	f8df 9038 	ldr.w	r9, [pc, #56]	; 8001290 <_startup_tasks_create+0x44>
 800125a:	00e7      	lsls	r7, r4, #3
 800125c:	1b3b      	subs	r3, r7, r4
 800125e:	ea4f 0883 	mov.w	r8, r3, lsl #2
 8001262:	eb09 0608 	add.w	r6, r9, r8
 8001266:	68b1      	ldr	r1, [r6, #8]
		xTaskCreate(
 8001268:	6933      	ldr	r3, [r6, #16]
 800126a:	89b2      	ldrh	r2, [r6, #12]
 800126c:	6870      	ldr	r0, [r6, #4]
 800126e:	4645      	mov	r5, r8
 8001270:	3518      	adds	r5, #24
 8001272:	444d      	add	r5, r9
 8001274:	9501      	str	r5, [sp, #4]
 8001276:	6975      	ldr	r5, [r6, #20]
 8001278:	9500      	str	r5, [sp, #0]
 800127a:	f7ff fafd 	bl	8000878 <xTaskCreate>
		startup_tasks[i].result =
 800127e:	f849 0008 	str.w	r0, [r9, r8]
	for(int i = 0; i < COUNT(startup_tasks); i++)
 8001282:	3401      	adds	r4, #1
 8001284:	2c01      	cmp	r4, #1
 8001286:	d9e6      	bls.n	8001256 <_startup_tasks_create+0xa>
		startup_tasks[i].stack_depth,
		startup_tasks[i].parameters,
		startup_tasks[i].priority,
		&startup_tasks[i].created_task);
	}
}
 8001288:	b003      	add	sp, #12
 800128a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800128e:	bf00      	nop
 8001290:	20000010 	.word	0x20000010

08001294 <os_start>:

void os_start() {
 8001294:	b508      	push	{r3, lr}
	_startup_tasks_create();
 8001296:	f7ff ffd9 	bl	800124c <_startup_tasks_create>
	vTaskStartScheduler();
 800129a:	f7ff fb1f 	bl	80008dc <vTaskStartScheduler>
}
 800129e:	bd08      	pop	{r3, pc}

080012a0 <thread_init>:
#include "mw_redefines.h"
#include "FreeRTOSConfig.h"
#include "FreeRTOS.h"
#include "task.h"

extern void thread_init() {
 80012a0:	b508      	push	{r3, lr}
	for (int a = 0; a < 1000000; a++) {
 80012a2:	2300      	movs	r3, #0
 80012a4:	e001      	b.n	80012aa <thread_init+0xa>
		asm("NOP");
 80012a6:	bf00      	nop
	for (int a = 0; a < 1000000; a++) {
 80012a8:	3301      	adds	r3, #1
 80012aa:	4a03      	ldr	r2, [pc, #12]	; (80012b8 <thread_init+0x18>)
 80012ac:	4293      	cmp	r3, r2
 80012ae:	ddfa      	ble.n	80012a6 <thread_init+0x6>
	}
	for (;;) {
		vTaskDelay(10);
 80012b0:	200a      	movs	r0, #10
 80012b2:	f7ff fc61 	bl	8000b78 <vTaskDelay>
 80012b6:	e7fb      	b.n	80012b0 <thread_init+0x10>
 80012b8:	000f423f 	.word	0x000f423f

080012bc <thread_test>:
	}
}

extern void thread_test() {
 80012bc:	b508      	push	{r3, lr}
	for (int a = 0; a < 1000000; a++) {
 80012be:	2300      	movs	r3, #0
 80012c0:	e001      	b.n	80012c6 <thread_test+0xa>
		asm("NOP");
 80012c2:	bf00      	nop
	for (int a = 0; a < 1000000; a++) {
 80012c4:	3301      	adds	r3, #1
 80012c6:	4a03      	ldr	r2, [pc, #12]	; (80012d4 <thread_test+0x18>)
 80012c8:	4293      	cmp	r3, r2
 80012ca:	ddfa      	ble.n	80012c2 <thread_test+0x6>
	}
	for (;;) {
		vTaskDelay(0);
 80012cc:	2000      	movs	r0, #0
 80012ce:	f7ff fc53 	bl	8000b78 <vTaskDelay>
 80012d2:	e7fb      	b.n	80012cc <thread_test+0x10>
 80012d4:	000f423f 	.word	0x000f423f

080012d8 <__libc_init_array>:
 80012d8:	b570      	push	{r4, r5, r6, lr}
 80012da:	4e0d      	ldr	r6, [pc, #52]	; (8001310 <__libc_init_array+0x38>)
 80012dc:	4c0d      	ldr	r4, [pc, #52]	; (8001314 <__libc_init_array+0x3c>)
 80012de:	1ba4      	subs	r4, r4, r6
 80012e0:	10a4      	asrs	r4, r4, #2
 80012e2:	2500      	movs	r5, #0
 80012e4:	42a5      	cmp	r5, r4
 80012e6:	d109      	bne.n	80012fc <__libc_init_array+0x24>
 80012e8:	4e0b      	ldr	r6, [pc, #44]	; (8001318 <__libc_init_array+0x40>)
 80012ea:	4c0c      	ldr	r4, [pc, #48]	; (800131c <__libc_init_array+0x44>)
 80012ec:	f000 f89c 	bl	8001428 <_init>
 80012f0:	1ba4      	subs	r4, r4, r6
 80012f2:	10a4      	asrs	r4, r4, #2
 80012f4:	2500      	movs	r5, #0
 80012f6:	42a5      	cmp	r5, r4
 80012f8:	d105      	bne.n	8001306 <__libc_init_array+0x2e>
 80012fa:	bd70      	pop	{r4, r5, r6, pc}
 80012fc:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 8001300:	4798      	blx	r3
 8001302:	3501      	adds	r5, #1
 8001304:	e7ee      	b.n	80012e4 <__libc_init_array+0xc>
 8001306:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 800130a:	4798      	blx	r3
 800130c:	3501      	adds	r5, #1
 800130e:	e7f2      	b.n	80012f6 <__libc_init_array+0x1e>
 8001310:	0800145c 	.word	0x0800145c
 8001314:	0800145c 	.word	0x0800145c
 8001318:	0800145c 	.word	0x0800145c
 800131c:	08001464 	.word	0x08001464

08001320 <memset>:
 8001320:	4402      	add	r2, r0
 8001322:	4603      	mov	r3, r0
 8001324:	4293      	cmp	r3, r2
 8001326:	d100      	bne.n	800132a <memset+0xa>
 8001328:	4770      	bx	lr
 800132a:	f803 1b01 	strb.w	r1, [r3], #1
 800132e:	e7f9      	b.n	8001324 <memset+0x4>

08001330 <register_fini>:
 8001330:	4b02      	ldr	r3, [pc, #8]	; (800133c <register_fini+0xc>)
 8001332:	b113      	cbz	r3, 800133a <register_fini+0xa>
 8001334:	4802      	ldr	r0, [pc, #8]	; (8001340 <register_fini+0x10>)
 8001336:	f000 b805 	b.w	8001344 <atexit>
 800133a:	4770      	bx	lr
 800133c:	00000000 	.word	0x00000000
 8001340:	08001351 	.word	0x08001351

08001344 <atexit>:
 8001344:	2300      	movs	r3, #0
 8001346:	4601      	mov	r1, r0
 8001348:	461a      	mov	r2, r3
 800134a:	4618      	mov	r0, r3
 800134c:	f000 b816 	b.w	800137c <__register_exitproc>

08001350 <__libc_fini_array>:
 8001350:	b538      	push	{r3, r4, r5, lr}
 8001352:	4d07      	ldr	r5, [pc, #28]	; (8001370 <__libc_fini_array+0x20>)
 8001354:	4c07      	ldr	r4, [pc, #28]	; (8001374 <__libc_fini_array+0x24>)
 8001356:	1b64      	subs	r4, r4, r5
 8001358:	10a4      	asrs	r4, r4, #2
 800135a:	b91c      	cbnz	r4, 8001364 <__libc_fini_array+0x14>
 800135c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 8001360:	f000 b868 	b.w	8001434 <_fini>
 8001364:	3c01      	subs	r4, #1
 8001366:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
 800136a:	4798      	blx	r3
 800136c:	e7f5      	b.n	800135a <__libc_fini_array+0xa>
 800136e:	bf00      	nop
 8001370:	08001464 	.word	0x08001464
 8001374:	08001468 	.word	0x08001468

08001378 <__retarget_lock_acquire_recursive>:
 8001378:	4770      	bx	lr

0800137a <__retarget_lock_release_recursive>:
 800137a:	4770      	bx	lr

0800137c <__register_exitproc>:
 800137c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8001380:	4c26      	ldr	r4, [pc, #152]	; (800141c <__register_exitproc+0xa0>)
 8001382:	4606      	mov	r6, r0
 8001384:	6820      	ldr	r0, [r4, #0]
 8001386:	4698      	mov	r8, r3
 8001388:	460f      	mov	r7, r1
 800138a:	4691      	mov	r9, r2
 800138c:	f7ff fff4 	bl	8001378 <__retarget_lock_acquire_recursive>
 8001390:	4b23      	ldr	r3, [pc, #140]	; (8001420 <__register_exitproc+0xa4>)
 8001392:	681d      	ldr	r5, [r3, #0]
 8001394:	f8d5 0148 	ldr.w	r0, [r5, #328]	; 0x148
 8001398:	b918      	cbnz	r0, 80013a2 <__register_exitproc+0x26>
 800139a:	f505 70a6 	add.w	r0, r5, #332	; 0x14c
 800139e:	f8c5 0148 	str.w	r0, [r5, #328]	; 0x148
 80013a2:	6843      	ldr	r3, [r0, #4]
 80013a4:	2b1f      	cmp	r3, #31
 80013a6:	dd19      	ble.n	80013dc <__register_exitproc+0x60>
 80013a8:	4b1e      	ldr	r3, [pc, #120]	; (8001424 <__register_exitproc+0xa8>)
 80013aa:	b933      	cbnz	r3, 80013ba <__register_exitproc+0x3e>
 80013ac:	6820      	ldr	r0, [r4, #0]
 80013ae:	f7ff ffe4 	bl	800137a <__retarget_lock_release_recursive>
 80013b2:	f04f 30ff 	mov.w	r0, #4294967295
 80013b6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 80013ba:	f44f 70c8 	mov.w	r0, #400	; 0x190
 80013be:	f3af 8000 	nop.w
 80013c2:	2800      	cmp	r0, #0
 80013c4:	d0f2      	beq.n	80013ac <__register_exitproc+0x30>
 80013c6:	f8d5 3148 	ldr.w	r3, [r5, #328]	; 0x148
 80013ca:	6003      	str	r3, [r0, #0]
 80013cc:	2200      	movs	r2, #0
 80013ce:	6042      	str	r2, [r0, #4]
 80013d0:	f8c5 0148 	str.w	r0, [r5, #328]	; 0x148
 80013d4:	f8c0 2188 	str.w	r2, [r0, #392]	; 0x188
 80013d8:	f8c0 218c 	str.w	r2, [r0, #396]	; 0x18c
 80013dc:	6843      	ldr	r3, [r0, #4]
 80013de:	b19e      	cbz	r6, 8001408 <__register_exitproc+0x8c>
 80013e0:	eb00 0583 	add.w	r5, r0, r3, lsl #2
 80013e4:	2201      	movs	r2, #1
 80013e6:	f8c5 9088 	str.w	r9, [r5, #136]	; 0x88
 80013ea:	f8d0 1188 	ldr.w	r1, [r0, #392]	; 0x188
 80013ee:	409a      	lsls	r2, r3
 80013f0:	4311      	orrs	r1, r2
 80013f2:	2e02      	cmp	r6, #2
 80013f4:	f8c0 1188 	str.w	r1, [r0, #392]	; 0x188
 80013f8:	f8c5 8108 	str.w	r8, [r5, #264]	; 0x108
 80013fc:	bf02      	ittt	eq
 80013fe:	f8d0 118c 	ldreq.w	r1, [r0, #396]	; 0x18c
 8001402:	430a      	orreq	r2, r1
 8001404:	f8c0 218c 	streq.w	r2, [r0, #396]	; 0x18c
 8001408:	1c5a      	adds	r2, r3, #1
 800140a:	3302      	adds	r3, #2
 800140c:	6042      	str	r2, [r0, #4]
 800140e:	f840 7023 	str.w	r7, [r0, r3, lsl #2]
 8001412:	6820      	ldr	r0, [r4, #0]
 8001414:	f7ff ffb1 	bl	800137a <__retarget_lock_release_recursive>
 8001418:	2000      	movs	r0, #0
 800141a:	e7cc      	b.n	80013b6 <__register_exitproc+0x3a>
 800141c:	20000470 	.word	0x20000470
 8001420:	08001458 	.word	0x08001458
 8001424:	00000000 	.word	0x00000000

08001428 <_init>:
 8001428:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800142a:	bf00      	nop
 800142c:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800142e:	bc08      	pop	{r3}
 8001430:	469e      	mov	lr, r3
 8001432:	4770      	bx	lr

08001434 <_fini>:
 8001434:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001436:	bf00      	nop
 8001438:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800143a:	bc08      	pop	{r3}
 800143c:	469e      	mov	lr, r3
 800143e:	4770      	bx	lr
